//@version=6
strategy("FinalStrat", calc_on_every_tick = true, max_boxes_count = 500)
var int higher_tf_minutes = input.int(7, title = "Higher Timeframe in Minutes")
var int entry_tf_minutes = input.int(2, title = "Entry Timeframe in Minutes")
var bool should_print_higher_tf_candles = input.bool(false, title = "Print Higher Timeframe Candles")
var bool should_print_entry_tf_candles = input.bool(false, title = "Print Entry Timeframe Candles")
var int script_tf_minutes = MiscLibrary_scriptTimeframeInMinutes()
var bool should_print_higher_tf_fvgs = input.bool(false, title = "Print Higher Timeframe FVGs")
var bool should_print_entry_tf_fvgs = input.bool(false, title = "Print Entry Timeframe FVGs")
var bool should_print_higher_tf_candles_label = input.bool(false, title = "Print Higher Timeframe Label")
var bool should_print_entry_tf_candles_label = input.bool(false, title = "Print Entry Timeframe Label")

var bool candle_labels_have_FVG_info = input.bool(false, title = "Candle Labels Have FVG Info")
var float minimum_FVG_size_usd = input.float(9, title = "Minimum FVG Size in USD", step = 0.25)

var bool has_invalid_input = (script_tf_minutes < entry_tf_minutes) or (script_tf_minutes < higher_tf_minutes) or (entry_tf_minutes > higher_tf_minutes)



//place a trade based on an entry 
FinalStrategy_process_entry(Entry entry) =>
    bool should_place_trade = (entry.state == EntryState.Placed) and (entry.index == bar_index)
    if should_place_trade
        string trade_id = str.tostring(entry.index)
        entry.additional_data.trade_id := trade_id
        bool is_long = entry.dir == Direction.Long
        bool is_short = entry.dir == Direction.Short
        bool is_entry_limit = entry.orderType == OrderType.Limit
        bool is_entry_stop = entry.orderType == OrderType.Stop
        if is_entry_limit
            strategy.entry(id = trade_id, direction = is_long ? strategy.long : strategy.short, limit = entry.entryPrice, qty = entry.num_shares)
        if is_entry_stop
            strategy.entry(id = trade_id, direction = is_long ? strategy.long : strategy.short, stop = entry.entryPrice, qty = entry.num_shares)
        string exit_id = "exit_" + trade_id
        strategy.exit(id = exit_id, from_entry = trade_id, stop = entry.stopLossPrice, limit = entry.targetPrice)

    bool should_cancel_trade = (entry.state == EntryState.Invalidated)
    if should_cancel_trade
        strategy.cancel(id = entry.additional_data.trade_id)


//////////////////////////////////////// TESTING ///////////////////////////////////////////
type CustomStategyTimeframeArgsDebugger
    bool should_print_candles = false 
    bool should_label_candles = false 
    bool should_draw_FVGs = false
    bool labels_include_FVG_info = false
    bool is_candle_in_higher_tf_FVG = false

type CustomStrategyTimeframeArgs 
    InsideCandleArgs inside_candle_args = na
    FairValueGapLibraryArgs fvg_args = na
    CustomStategyTimeframeArgsDebugger debug_info = na

helper_createCustomStrategyTimeframeArgs() => 
    CustomStrategyTimeframeArgs args = CustomStrategyTimeframeArgs.new()
    args.debug_info := CustomStategyTimeframeArgsDebugger.new()
    args 


type CustomStrategyArgs 
    array<int> timeframes = na 
    MultiTimeFrameLibraryArgs multi_timeframe_library_args = na 
    array<CustomStrategyTimeframeArgs> timeframe_args = na
    int highest_tf = 0 
    int lowest_tf = 0 
create_CustomStrategyArgs() => 
    CustomStrategyArgs args = CustomStrategyArgs.new() 
    args.timeframes := array.new<int>() 
    args.multi_timeframe_library_args := create_MultiTimeFrameLibraryArgs() 
    args.timeframe_args := array.new<CustomStrategyTimeframeArgs>() 
    args

customStrategy_addTimeframe(CustomStrategyArgs args, int timeframe, bool tracks_inside_candle = false, bool tracks_FVGs = false) => 
    CustomStrategyTimeframeArgs time_frame_args = helper_createCustomStrategyTimeframeArgs()
    MultiTimeFrameLibrary_keepTrackofTimeFrame(args.multi_timeframe_library_args, timeframe)

    // If tracking FVGs, we must also track inside candles
    bool enable_inside_candle = tracks_inside_candle or tracks_FVGs

    // Inside candle tracker 
    InsideCandleArgs inside_candle_args = na 
    if enable_inside_candle
        inside_candle_args := create_InsideCandleArgs()
    time_frame_args.inside_candle_args := inside_candle_args

    // FVG tracking
    FairValueGapLibraryArgs fvg_args = na
    if tracks_FVGs
        fvg_args := create_FairValueGapLibraryArgs()
        fvg_args.enable_debugging := true  // Enable drawing/debugging as needed
    time_frame_args.fvg_args := fvg_args

    args.timeframe_args.push(time_frame_args)
    args.timeframes.push(timeframe)

    //update highest and lowest tf
    if args.highest_tf == 0 or timeframe > args.highest_tf 
        args.highest_tf := timeframe
    if args.lowest_tf == 0 or timeframe < args.lowest_tf
        args.lowest_tf := timeframe

helper_customStrategy_update_highTF(CustomStrategyArgs args, int timeframe, TimeFrameCandle current_candle, bool update_higher_tf_values = false, int higher_tf = -1) =>
    int timeframe_index = args.timeframes.indexof(timeframe)
    CustomStrategyTimeframeArgs time_frame_args = args.timeframe_args.get(timeframe_index)
    int higher_tf_index = 0 
    CustomStrategyTimeframeArgs higher_tf_args = na
    if update_higher_tf_values
        higher_tf_index := args.timeframes.indexof(higher_tf)
        higher_tf_args := args.timeframe_args.get(higher_tf_index)


    // Update inside candle lib first
    InsideCandleArgs inside_candle_args = time_frame_args.inside_candle_args
    if not na(inside_candle_args)
        InsideCandleLibrary_processCandle(inside_candle_args, current_candle)

    // Update FVGs if enabled, passing in inside candle info
    FairValueGapLibraryArgs fvg_args = time_frame_args.fvg_args
    if not na(fvg_args) and not na(inside_candle_args)
        InsideCandleInfo inside_info = inside_candle_args.current_candle_info
        FairValueGapLibrary_processCandleHighTF(fvg_args, current_candle, inside_info)


    //update higher timeframe values if applicable 
    if update_higher_tf_values and not na(higher_tf_args)
        //update higher timeframe FVG values 
        FairValueGapLibraryArgs higher_tf_fvg_args = higher_tf_args.fvg_args
        if not na(higher_tf_fvg_args)
            bool is_inside_fvg = FairValueGapLibrary_doesCandleInteractWithFVGs(higher_tf_fvg_args, current_candle, overlaps_bearish = true, overlaps_bullish = true)
            current_candle.debug_info.is_candle_in_higher_tf_FVG := is_inside_fvg

    

    //debugging / drawing 
    if time_frame_args.debug_info.should_print_candles
        current_candle.debug_info.candle_should_have_label := time_frame_args.debug_info.should_label_candles
        if time_frame_args.debug_info.should_label_candles
            label_text = str.tostring(current_candle.bar_index_in_own_timeframe) + " TF: " + str.tostring(current_candle.timeframe) + "\n"
            if time_frame_args.debug_info.labels_include_FVG_info
                if current_candle.debug_info.is_candle_in_higher_tf_FVG
                    label_text += "In Higher TF FVG\n"
            current_candle.debug_info.label_text := label_text
        MultiTimeFrameLibraryDebugger_drawCandle(args.multi_timeframe_library_args, current_candle)

helper_customStrategy_update_scriptTF(CustomStrategyArgs args, int timeframe_index, TimeFrameCandle current_candle) =>
    CustomStrategyTimeframeArgs time_frame_args = args.timeframe_args.get(timeframe_index)

    // Update FVGs if enabled, passing in inside candle info
    FairValueGapLibraryArgs fvg_args = time_frame_args.fvg_args
    if not na(fvg_args)
        FairValueGapLibrary_processCandleScriptTF(fvg_args, current_candle)





customStrategy_update(CustomStrategyArgs args) => 
    MultiTimeFrameLibrary_update(args.multi_timeframe_library_args)
    //check if we have any new HTF candles 
    MultiTimeFrameLibraryOutput timeframe_lib_output = args.multi_timeframe_library_args.output
    if timeframe_lib_output.something_has_changed
        if timeframe_lib_output.timeframe_candle_has_changed.size() > 0 
            for i = timeframe_lib_output.timeframe_candle_has_changed.size() - 1 to 0 
                bool candle_has_changed = timeframe_lib_output.timeframe_candle_has_changed.get(i)
                if candle_has_changed
                    TimeFrameCandle current_candle = timeframe_lib_output.current_candles.get(i)
                    int current_tf = args.multi_timeframe_library_args.time_frames.get(i)
                    if current_tf == args.highest_tf 
                        helper_customStrategy_update_highTF(args, current_tf, current_candle, update_higher_tf_values = false)
                    else 
                        helper_customStrategy_update_highTF(args, current_tf, current_candle, update_higher_tf_values = true, higher_tf = args.highest_tf)
    // then process the script candle 
    TimeFrameCandle script_candle = MultiTimeFrameLibrary_createCurrentCandle(args.multi_timeframe_library_args, script_tf_minutes)
    if args.timeframes.size() > 0 
        for i = args.timeframes.size() - 1 to 0 
            helper_customStrategy_update_scriptTF(args, i, script_candle)

            

//returns CustomStrategyTimeframeArgs of whatever timeframe passed in (pass in timeframe, not index). Returns null if error
customStrategy_getTimeframeArgs(CustomStrategyArgs args, int timeframe_in) =>
    CustomStrategyTimeframeArgs result = na 
    if args.timeframes.size () > 0 
        for i = args.timeframes.size() - 1 to 0 
            if args.timeframes.get(i) == timeframe_in 
                result := args.timeframe_args.get(i)
                break 
    result 

//Initialize Custom Strategy Args
var CustomStrategyArgs custom_strategy_args = create_CustomStrategyArgs()
var bool is_initialized = false 
var CustomStrategyTimeframeArgs timeframe_args_higher_tf = na
var CustomStrategyTimeframeArgs timeframe_args_entry_tf = na
if not is_initialized 
    // Enable FVG tracking for 5min timeframe (auto-enables inside candles)
    customStrategy_addTimeframe(custom_strategy_args, higher_tf_minutes, tracks_inside_candle = true, tracks_FVGs = true)
    customStrategy_addTimeframe(custom_strategy_args, entry_tf_minutes, tracks_inside_candle = true, tracks_FVGs = true)
    custom_strategy_args.multi_timeframe_library_args.debugger.debugger_enabled := true 
    custom_strategy_args.multi_timeframe_library_args.debugger.draw_all_candles := false
    //MultiTimeFrameLibraryDebugger_toggleDrawHigherTimeFrameCandles(custom_strategy_args.multi_timeframe_library_args, higher_tf_minutes,value = should_print_higher_tf_candles, value_label = should_print_higher_tf_candles_label)
    //MultiTimeFrameLibraryDebugger_toggleDrawHigherTimeFrameCandles(custom_strategy_args.multi_timeframe_library_args, entry_tf_minutes,value = should_print_entry_tf_candles, value_label = should_print_entry_tf_candles_label)
     
    timeframe_args_higher_tf := customStrategy_getTimeframeArgs(custom_strategy_args, higher_tf_minutes)
    timeframe_args_entry_tf := customStrategy_getTimeframeArgs(custom_strategy_args, entry_tf_minutes)
    //set should draw candles 
    timeframe_args_higher_tf.debug_info.should_print_candles := should_print_higher_tf_candles
    timeframe_args_entry_tf.debug_info.should_print_candles := should_print_entry_tf_candles
    //set should label candles
    timeframe_args_higher_tf.debug_info.should_label_candles := should_print_higher_tf_candles_label
    timeframe_args_entry_tf.debug_info.should_label_candles := should_print_entry_tf_candles_label
    //set should draw FVGs
    FairValueGapLibraryDebugger_setDebuggerSettings(timeframe_args_higher_tf.fvg_args, should_print_FVGs = should_print_higher_tf_fvgs)
    FairValueGapLibraryDebugger_setDebuggerSettings(timeframe_args_entry_tf.fvg_args, should_print_FVGs = should_print_entry_tf_fvgs)
    //set FVG minimum size
    timeframe_args_higher_tf.fvg_args.minimum_FVG_size_usd := minimum_FVG_size_usd
    timeframe_args_entry_tf.fvg_args.minimum_FVG_size_usd := minimum_FVG_size_usd
    //set candle labels should have FVG info  
    timeframe_args_higher_tf.debug_info.labels_include_FVG_info := candle_labels_have_FVG_info
    timeframe_args_entry_tf.debug_info.labels_include_FVG_info := candle_labels_have_FVG_info
    
    is_initialized := true
customStrategy_update(custom_strategy_args)

CustomStrategyTimeframeArgs timeframe_args__higher_tf = customStrategy_getTimeframeArgs(custom_strategy_args, higher_tf_minutes)





var EntryLibraryArgs args = create_EntryLibraryArgs()
args.trade_library_args.debugger.print_active_trades_when_something_changes := false 
// want to code in Longs for Green Down Candles, and Shorts for Red Up Candles 


//base level entry patterns (red up, green down, inside / outside candles)
var string red_up_candle_condition_name = "is_red_up_candle"
var string green_down_candle_condition_name = "is_green_down_candle"
var string inside_candle_condition_name = "is_inside_candle"
var string outside_candle_condition_name = "is_outside_candle"
bool is_red_up_candle = timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_candle_red and timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_up_candle and not timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_inside_candle and not timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_outside_candle
bool is_green_down_candle = timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_candle_green and timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_down_candle and not timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_inside_candle and not timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_outside_candle
bool is_inside_candle = timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_inside_candle
bool is_outside_candle = timeframe_args__higher_tf.inside_candle_args.current_candle_info.is_outside_candle
update_simple_condition(args, red_up_candle_condition_name, is_red_up_candle)
update_simple_condition(args, green_down_candle_condition_name, is_green_down_candle)
update_simple_condition(args, inside_candle_condition_name, is_inside_candle)
update_simple_condition(args, outside_candle_condition_name, is_outside_candle)

var string price_in_higher_tf_bullish_FVG_condition_name = "is_price_in_bullish_FVG_higher_tf"
var string price_in_higher_tf_bearish_FVG_condition_name = "is_price_in_bearish_FVG_higher_tf"
bool is_price_in_bearish_FVG__higher_tf = timeframe_args__higher_tf.fvg_args.is_price_in_bearish_FVG
bool is_price_in_bullish_FVG__higher_tf = timeframe_args__higher_tf.fvg_args.is_price_in_bullish_FVG
update_simple_condition(args, price_in_higher_tf_bullish_FVG_condition_name, is_price_in_bullish_FVG__higher_tf)
update_simple_condition(args, price_in_higher_tf_bearish_FVG_condition_name, is_price_in_bearish_FVG__higher_tf)


var string past_start_time_condition_name = "is_past_start_time"
is_after_datetime(int year_in, int month_in, int day_in, int hour_in, int minute_in) =>
    int target_timestamp = timestamp("UTC", year_in, month_in, day_in, hour_in, minute_in)
    bool is_past = time >= target_timestamp
    is_past
update_simple_condition(args,past_start_time_condition_name, is_after_datetime(2025,6,4,0,0))



// entry actions 
var entry_action_long_stop_name = "Place Long Stop On Current Candle"
var entry_action_short_stop_name = "Place Short Stop On Current Candle"
var EntryAction entry_action_long_stop = create_and_add_EntryAction(args, entry_action_long_stop_name, ENTRY_ACTION_TYPE.EntryIsCandle,Direction.Long, OrderType.Stop)
var EntryAction entry_action_short_stop = create_and_add_EntryAction(args, entry_action_short_stop_name, ENTRY_ACTION_TYPE.EntryIsCandle,Direction.Short, OrderType.Stop)

//key levels 
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma20", ta.sma(close, 20))
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma50", ta.sma(close, 50))
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma100", ta.sma(close, 100))
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma200", ta.sma(close, 200))

var string touching_sma_condition_name = "TouchingSMA_20_50_100_200"
update_simple_condition(args,touching_sma_condition_name, KeyLevelLibrary_isPriceTouchingAnyKeyLevel(args.key_level_library_args))



// Rules Taking Entries touching Key Levels For 1R
var exit_action_1R_name = "Exit at 1R"
var ExitAction exit_action_1R = create_and_add_ExitAction(args, exit_action_1R_name, EXIT_ACTION_TYPE.SetRiskRewardRatio, 1)
var rc = EntryStrategyLibrary_updateExitActionBreakeven(args, exit_action_1R_name, will_break_even = true, breakeven_on_n = 1)

var string red_up_1r_rule_name = "Red_Up_Candle_Touching_Key_Level_1R_Rule"
var string green_down_1r_rule_name = "Green_Down_Candle_Touching_Key_Level_1R_Rule"
var EntryRule red_up_1r_rule = create_and_add_EntryRule(args, red_up_1r_rule_name, red_up_candle_condition_name, entry_action_short_stop_name, exit_action_1R_name)
var EntryRule green_down_1r_rule = create_and_add_EntryRule(args, green_down_1r_rule_name, green_down_candle_condition_name, entry_action_long_stop_name, exit_action_1R_name)

add_condition_to_EntryRule(args, red_up_1r_rule_name, past_start_time_condition_name)
add_condition_to_EntryRule(args, green_down_1r_rule_name, past_start_time_condition_name)
//add_condition_to_EntryRule(args, red_up_1r_rule_name, touching_sma_condition_name)
//add_condition_to_EntryRule(args, green_down_1r_rule_name, touching_sma_condition_name)


// Rules Taking Entries making 1R or less touching nearest key level 
// var exit_action_nearest_key_level_long_name = "Exit at nearest key level LONG"
// var ExitAction exit_action_nearest_key_level_long = create_and_add_ExitAction(args, exit_action_nearest_key_level_long_name, EXIT_ACTION_TYPE.SetTargetPrice, 0) //need to update this every bar
// var exit_action_nearest_key_level_short_name = "Exit at nearest key level SHORT"
// var ExitAction exit_action_nearest_key_level_short = create_and_add_ExitAction(args, exit_action_nearest_key_level_short_name, EXIT_ACTION_TYPE.SetTargetPrice, 0) //need to update this every bar

// var string red_up_nearest_level_rule_name = "Red_Up_Candle_Near_Key_Level_Rule"
// var string green_down_nearest_level_rule_name = "Green_Down_Candle_Near_Key_Level_Rule"
// var EntryRule red_up_nearest_level_rule = create_and_add_EntryRule(args, red_up_nearest_level_rule_name, red_up_candle_condition_name, entry_action_short_stop_name, exit_action_nearest_key_level_short_name)
// var EntryRule green_down_nearest_level_rule = create_and_add_EntryRule(args, green_down_nearest_level_rule_name, green_down_candle_condition_name, entry_action_long_stop_name, exit_action_nearest_key_level_long_name)


// var string near_sma_condition_long_name = "NearSMA_20_50_100_200 LONG"
// KeyLevel nearest_key_level_long = KeyLevelLibrary_getNearestKeyLevelLong(args.key_level_library_args, true)
// bool is_near_sma_long_helper = false 
// if not na(nearest_key_level_long)
//     is_near_sma_long_helper := MiscLibrary_isMakingAtMost_R_toPrice(high, low, nearest_key_level_long.current_value, 1)
//     update_exit_action_value(args, exit_action_nearest_key_level_long_name, nearest_key_level_long.current_value)
// update_simple_condition(args, near_sma_condition_long_name, is_near_sma_long_helper)


// var string near_sma_condition_short_name = "NearSMA_20_50_100_200 SHORT"
// KeyLevel nearest_key_level_short = KeyLevelLibrary_getNearestKeyLevelShort(args.key_level_library_args, true)
// bool is_near_sma_short_helper = false 
// if not na(nearest_key_level_short)
//     is_near_sma_short_helper := MiscLibrary_isMakingAtMost_R_toPrice(low, high, nearest_key_level_short.current_value, 1)
//     update_exit_action_value(args, exit_action_nearest_key_level_short_name, nearest_key_level_short.current_value)
// update_simple_condition(args, near_sma_condition_short_name, is_near_sma_long_helper)


// add_condition_to_EntryRule(args, red_up_nearest_level_rule_name, past_start_time_condition_name)
// add_condition_to_EntryRule(args, green_down_nearest_level_rule_name, past_start_time_condition_name)
// add_condition_to_EntryRule(args, red_up_nearest_level_rule_name, near_sma_condition_short_name)
// add_condition_to_EntryRule(args, green_down_nearest_level_rule_name, near_sma_condition_long_name)



args.process_longs := false 
args.process_shorts := false 
args.trade_library_args.parameters.pyramiding_allowed := true
EntryStrategyLibrary_process_candle(args)

array<Entry> entries = args.trade_library_args.entry_array
if entries.size() > 0 
    for i = entries.size() - 1 to 0 
        FinalStrategy_process_entry(entries.get(i))

