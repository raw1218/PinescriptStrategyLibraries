type FairValueGapInfo_AdditionalData
    bool tapped_into = false 
    float tapped_into_deepest_price = 0 
    bool pending_disrespected  = false //so that we hold onto to see if an IFVG forms before deleting it 

    int draw_left_bar_index = 0 //left bar index (in script timeframe) for drawing the FVG box
    int added_on_bar_index = 0 //the bar index when this FVG was added to the active list (to avoid processing it as tapped into as soon as we add it)
create_FairValueGapInfo_AdditionalData() => 
    FairValueGapInfo_AdditionalData additional_data = FairValueGapInfo_AdditionalData.new() 
    additional_data

type FairValueGapInfo 
    int bar_index = 0 
    bool is_bullish_fvg = false 
    bool is_bearish_fvg = false 
    float FVG_high = 0
    float FVG_low = 0
    FairValueGapInfo_AdditionalData additional_data = na
create_FairValueGapInfo() =>
    FairValueGapInfo fvg_info = FairValueGapInfo.new() 
    fvg_info.additional_data := create_FairValueGapInfo_AdditionalData()
    fvg_info

type FairValueGapLibraryArgs_DebugInfo
    bool should_print_FVGs = false 
    
type FairValueGapLibraryArgs 
    array<FairValueGapInfo> active_FVGs = na
    int max_active_FVGs = 50
    int num_candles_to_track = 3 //track 3 most recent candles 
    array<TimeFrameCandle> most_recent_candles = na
    array<InsideCandleInfo> most_recent_candles_inside_info = na 
    bool last_candle_is_inside_candle = false //used to skip processing if the last candle is an inside candle


    bool enable_debugging = true    
    ChartDrawingArgs chart_drawing_args = na
    FairValueGapLibraryArgs_DebugInfo debug_info = na

    bool is_price_in_bullish_FVG = false 
    bool is_price_in_bearish_FVG = false
    float minimum_FVG_size_usd = 0 //minimum size of the FVG in USD to consider it valid, used for debugging purposes

    


create_FairValueGapLibraryArgs() => 
    FairValueGapLibraryArgs args = FairValueGapLibraryArgs.new() 
    args.active_FVGs := array.new<FairValueGapInfo>() 
    args.most_recent_candles := array.new<TimeFrameCandle>()
    args.most_recent_candles_inside_info := array.new<InsideCandleInfo>()
    args.enable_debugging := false
    args.chart_drawing_args := ChartDrawingLibrary_createChartDrawingArgs()
    args.debug_info := FairValueGapLibraryArgs_DebugInfo.new()
    args 
FairValueGapLibraryDebugger_setDebuggerSettings(FairValueGapLibraryArgs args, bool should_print_FVGs)=>
    args.debug_info.should_print_FVGs := should_print_FVGs


helper_FairValueGapLibrary_updateMostRecentCandle(FairValueGapLibraryArgs args, TimeFrameCandle current_candle, InsideCandleInfo inside_candle_info, bool replace_last_element = false) =>
    // Get the current array size
    int current_size = array.size(args.most_recent_candles)
    int max_size = args.num_candles_to_track
    InsideCandleInfo inside_candle_info_copy = InsideCandleInfo.new()
    InsideCandleLibrary_copyInsideCandleInfo(inside_candle_info, inside_candle_info_copy)

    //shift the list over 
    if not replace_last_element
        if current_size < max_size
            // If the array is not full, just append the new candle
            array.push(args.most_recent_candles, current_candle)
            array.push(args.most_recent_candles_inside_info, inside_candle_info_copy)
        else
            // Remove the oldest candle at index 0 and append the new one at the end
            array.remove(args.most_recent_candles, 0)
            array.push(args.most_recent_candles, current_candle)
            array.remove(args.most_recent_candles_inside_info, 0)
            array.push(args.most_recent_candles_inside_info, inside_candle_info_copy)

    //else replace the last element 
    else
        array.remove(args.most_recent_candles, 0)
        array.remove(args.most_recent_candles_inside_info, 0)
        current_size -= 1
        if current_size > 0
            // Replace the last element with the new candle
            array.set(args.most_recent_candles, current_size - 1, current_candle)
            array.set(args.most_recent_candles_inside_info, current_size - 1, inside_candle_info_copy)
        else
            // If the array is empty, just append the new candle
            array.push(args.most_recent_candles, current_candle)
            array.push(args.most_recent_candles_inside_info, inside_candle_info_copy)
        


helper_FairValueGapLibrary_removeActiveFVG(FairValueGapLibraryArgs args, int active_fvg_index) =>
    // Find the FVG with the matching bar index and remove it
    FairValueGapInfo fvg = args.active_FVGs.get(active_fvg_index)
    if not na(fvg)
        // Remove the FVG from the active list
        array.remove(args.active_FVGs, active_fvg_index)
        // Optionally, you can also remove the drawing from the chart if needed
        string group_name = "FVGs_Group"
        string item_name = "FVG_" + str.tostring(fvg.bar_index)
        ChartDrawingLibrary_FinishDrawing(args.chart_drawing_args, group_name, item_name)


helper_FairValueGapLibrary_addActiveFVG(FairValueGapLibraryArgs args, FairValueGapInfo new_fvg) =>
    bool is_valid_fvg = true
    if new_fvg.FVG_high - new_fvg.FVG_low < args.minimum_FVG_size_usd
        is_valid_fvg := false // FVG is too small, skip adding it

    if is_valid_fvg
        // Add the new FVG
        array.push(args.active_FVGs, new_fvg)
        // Remove the oldest if we exceed the max allowed
        if array.size(args.active_FVGs) > args.max_active_FVGs
            helper_FairValueGapLibrary_removeActiveFVG(args, 0) //remove the oldest FVG




helper_FairValueGapLibrary_processPotentialFVG(FairValueGapLibraryArgs args) => 
    //scan the most recent three candles to see if there is a gap 
    //assumes there are no inside candles in the recents 
    if args.most_recent_candles.size() == args.num_candles_to_track
        TimeFrameCandle first_candle = args.most_recent_candles.get(0)
        InsideCandleInfo first_candle_info = args.most_recent_candles_inside_info.get(0)
        TimeFrameCandle second_candle = args.most_recent_candles.get(1)
        InsideCandleInfo second_candle_info = args.most_recent_candles_inside_info.get(1)
        TimeFrameCandle third_candle = args.most_recent_candles.get(2)
        InsideCandleInfo third_candle_info = args.most_recent_candles_inside_info.get(2)

        //check for bullish FVG 
        bool all_up_candles = (third_candle_info.is_up_candle)
        bool all_down_candles = (third_candle_info.is_down_candle)
        bool is_potentially_a_FVG = (all_up_candles or all_down_candles)  and (not second_candle_info.is_inside_candle)
        float fvg_high = 0 
        float fvg_low = 0 
        bool is_bullish_fvg = false 
        bool is_bearish_fvg = false 
        if is_potentially_a_FVG
            if all_up_candles //check for bullish FVG 
                if third_candle.low_price > first_candle.high_price
                    is_bullish_fvg := true 
                    fvg_high := third_candle.low_price 
                    fvg_low := first_candle.high_price 
            else if all_down_candles 
                if third_candle.high_price < first_candle.low_price 
                    is_bearish_fvg := true 
                    fvg_high := first_candle.low_price 
                    fvg_low := third_candle.high_price 
        //create the FVG object 
        if is_bullish_fvg or is_bearish_fvg
            FairValueGapInfo fvg_info = create_FairValueGapInfo()
            fvg_info.is_bullish_fvg := is_bullish_fvg
            fvg_info.is_bearish_fvg := is_bearish_fvg 
            fvg_info.FVG_high := fvg_high 
            fvg_info.FVG_low := fvg_low
            fvg_info.bar_index := second_candle.bar_index_in_own_timeframe
            fvg_info.additional_data.draw_left_bar_index := second_candle.debug_info.first_bar_index 
            fvg_info.additional_data.added_on_bar_index := third_candle.bar_index_in_own_timeframe
            //add the FVG to the active list
            helper_FairValueGapLibrary_addActiveFVG(args, fvg_info)
            

helper_FairValueGapLibrary_drawActiveFVGs(FairValueGapLibraryArgs args) =>
    if args.enable_debugging and array.size(args.active_FVGs) > 0
        string group_name = "FVGs_Group"
        for i = 0 to array.size(args.active_FVGs) - 1
            FairValueGapInfo fvg = array.get(args.active_FVGs, i)
            string item_name = "FVG_" + str.tostring(fvg.bar_index)
            int left = fvg.additional_data.draw_left_bar_index
            int right = bar_index  // Draw to the latest bar index instead of left + 1
            float top = fvg.FVG_high
            float bottom = fvg.FVG_low
            // Set color: green for bullish, red for bearish, 25% visible (75 transparency)
            color base_color = fvg.is_bullish_fvg ? color.green : color.red
            color box_color = color.new(base_color, 75)
            color border_color = color.black
            ChartDrawingBox my_box = ChartDrawingLibrary_createChartDrawingBox(args.chart_drawing_args,top_price = top,bottom_price = bottom,left_bar_index = left,right_bar_index = right,bg_color = box_color,border_color = border_color)
            ChartDrawingLibrary_UpdateDrawing(args.chart_drawing_args,group_name,item_name,chart_box = my_box)


//Function to process a candle and see if we interact with any active Fair Value Gap (FVG)
// Removes invalidated FVGs from the active_FVGs array
helper_FairValueGapLibrary_processScriptCandleForFVGs(FairValueGapLibraryArgs args, TimeFrameCandle current_candle) =>
    args.is_price_in_bullish_FVG := false
    args.is_price_in_bearish_FVG := false
    // Loop backwards so removal is safe
    if array.size(args.active_FVGs) > 0
        for i = array.size(args.active_FVGs) - 1 to 0
            FairValueGapInfo fvg_info = array.get(args.active_FVGs, i)
            bool is_bullish_fvg = fvg_info.is_bullish_fvg
            bool is_bearish_fvg = fvg_info.is_bearish_fvg
            float fvg_high = fvg_info.FVG_high
            float fvg_low = fvg_info.FVG_low
            bool tapped_into = false 
            float tapped_into_deepest_price = 0.0
            bool invalidated = false

            // For bullish FVG: invalidated if candle closes below FVG low (or low < FVG low)
            // For bearish FVG: invalidated if candle closes above FVG high (or high > FVG high)
            if is_bullish_fvg
                // Invalidation logic: price blows through the FVG to the downside
                if current_candle.low_price < fvg_low
                    invalidated := true
                // Tapped into logic
                else if (current_candle.low_price <= fvg_high) and (current_candle.high_price >= fvg_low)
                    tapped_into := true 
                    tapped_into_deepest_price := math.max(current_candle.low_price, fvg_low)
                    args.is_price_in_bullish_FVG := true

            else if is_bearish_fvg
                // Invalidation logic: price blows through the FVG to the upside
                if current_candle.high_price > fvg_high
                    invalidated := true
                // Tapped into logic
                else if (current_candle.high_price >= fvg_low) and (current_candle.low_price <= fvg_high)
                    tapped_into := true 
                    tapped_into_deepest_price := math.min(current_candle.high_price, fvg_high)
                    args.is_price_in_bearish_FVG := true
                    

            // Update the FVG info with the interaction details
            if tapped_into
                fvg_info.additional_data.tapped_into := true 
                fvg_info.additional_data.tapped_into_deepest_price := tapped_into_deepest_price

            // Remove if invalidated, else mark as pending_disrespected
            if invalidated
                helper_FairValueGapLibrary_removeActiveFVG(args, i)


//Function to process a candle and update the Fair Value Gap librar
FairValueGapLibrary_processCandleHighTF(FairValueGapLibraryArgs args, TimeFrameCandle current_candle, InsideCandleInfo inside_candle_info) =>
    if args.last_candle_is_inside_candle
        //last candle and this candle are both inside candles, skip processing
        if not inside_candle_info.is_inside_candle
            args.last_candle_is_inside_candle := false 
            helper_FairValueGapLibrary_updateMostRecentCandle(args, current_candle, inside_candle_info, replace_last_element = true)
    else 
        //last candle was not an inside candle, but this one is, so we process it
        if inside_candle_info.is_inside_candle 
            args.last_candle_is_inside_candle := true
        helper_FairValueGapLibrary_updateMostRecentCandle(args, current_candle, inside_candle_info, replace_last_element = false)

    helper_FairValueGapLibrary_processPotentialFVG(args)




FairValueGapLibrary_processCandleScriptTF(FairValueGapLibraryArgs args, TimeFrameCandle current_candle) =>
    helper_FairValueGapLibrary_processScriptCandleForFVGs(args, current_candle)
    if args.enable_debugging and args.debug_info.should_print_FVGs
        helper_FairValueGapLibrary_drawActiveFVGs(args)








FairValueGapLibrary_doesCandleInteractWithFVGs(FairValueGapLibraryArgs args, TimeFrameCandle current_candle, bool overlaps_bullish = true, bool overlaps_bearish = true) =>
    // Check if the current candle interacts with any active FVGs
    bool is_in_bullish_FVG = false
    bool is_in_bearish_FVG = false
    bool result = false
    // Loop backwards so removal is safe
    if array.size(args.active_FVGs) > 0
        for i = array.size(args.active_FVGs) - 1 to 0
            FairValueGapInfo fvg_info = array.get(args.active_FVGs, i)
            bool is_bullish_fvg = fvg_info.is_bullish_fvg
            bool is_bearish_fvg = fvg_info.is_bearish_fvg
            float fvg_high = fvg_info.FVG_high
            float fvg_low = fvg_info.FVG_low
            bool tapped_into = false 
            float tapped_into_deepest_price = 0.0
            bool invalidated = false

            // For bullish FVG: invalidated if candle closes below FVG low (or low < FVG low)
            // For bearish FVG: invalidated if candle closes above FVG high (or high > FVG high)
            if is_bullish_fvg
                // Invalidation logic: price blows through the FVG to the downside
                if current_candle.low_price < fvg_low
                    invalidated := true
                // Tapped into logic
                else if (current_candle.low_price <= fvg_high) and (current_candle.high_price >= fvg_low)
                    tapped_into := true 
                    tapped_into_deepest_price := math.max(current_candle.low_price, fvg_low)
                    is_in_bullish_FVG := true

            else if is_bearish_fvg
                // Invalidation logic: price blows through the FVG to the upside
                if current_candle.high_price > fvg_high
                    invalidated := true
                // Tapped into logic
                else if (current_candle.high_price >= fvg_low) and (current_candle.low_price <= fvg_high)
                    tapped_into := true 
                    tapped_into_deepest_price := math.min(current_candle.high_price, fvg_high)
                    is_in_bearish_FVG := true

            bool interacts = (overlaps_bullish and is_in_bullish_FVG) or (overlaps_bearish and is_in_bearish_FVG)
            if interacts
                result := true 
                break
    result 
                    