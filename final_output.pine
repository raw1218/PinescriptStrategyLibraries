// === Libraries/MiscLibrary.pine ===
MiscLibrary_isMakingAtLeast_R_toPrice(float entry_price, float stop_loss_price, float target_price, float target_R) =>
    distance_to_stop = entry_price - stop_loss_price
    distance_to_target = target_price - entry_price
    float rr = distance_to_target / distance_to_stop
    rr >= target_R 

MiscLibrary_isMakingAtMost_R_toPrice(float entry_price, float stop_loss_price, float target_price, float target_R) =>
    distance_to_stop = entry_price - stop_loss_price
    distance_to_target = target_price - entry_price
    float rr = distance_to_target / distance_to_stop
    rr <= target_R 


// === Libraries/ChartDrawingLibrary.pine ===
/////////////// Chart Drawing Library //////////////////////////////////////////////////////////
//Supports grouping different sets of boxes / drawings into named groups
//Each group has one active (dynamic) drawing that updates every candle, and a set of finished (static) drawings that are drawn once. 
//Start_new_box(group_name, coordinates)
//Update_box(group_name, coordinates)
//Finish_box(group_name, coordinates)

type ChartDrawingHorizontalLine
	bool solid_line = true 
	color line_color = na 
	float price = 0 
	int left_x = 0
	int right_x = 0
	line tv_line_item = na

type ChartDrawingBox
	float top_price = na 
	float bottom_price = na 
	int left_bar_index = na 
	int right_bar_index = na
	color box_color = na 
	color border_color = na
	box tv_box_item = na
	array<ChartDrawingHorizontalLine> horizontal_lines = na

type ChartDrawingLabel
	int bar_index_x = na 
	float price_y = na 
	color label_color = na
	string label_text = na
	label tv_label_item = na 
	

type ChartDrawingItem
	string name = na
	ChartDrawingBox chart_box = na
	ChartDrawingLabel chart_label = na


type ChartDrawingGroup
	string name = na
	array<ChartDrawingItem> current_drawings = na
	array<ChartDrawingItem> finished_drawings = na 

	int max_boxes_in_group = 50 //no more than 50 boxes drawn from this group
	int max_box_width = 200  //if we try to draw a box thats that big


type ChartDrawingArgs
	array<ChartDrawingGroup> groups = na
ChartDrawingLibrary_createChartDrawingArgs() =>
	ChartDrawingArgs args = ChartDrawingArgs.new() 
	args.groups := array.new<ChartDrawingGroup>()
	args

helper_getChartDrawingGroupByName(ChartDrawingArgs args, string group_name) =>
	ChartDrawingGroup result = na 
	if args.groups.size() > 0
		for i = args.groups.size() - 1 to 0
			ChartDrawingGroup current_group = args.groups.get(i)
			if group_name == current_group.name
				result := current_group 
				break
	result 

helper_getCurrentChartDrawingItemByName(ChartDrawingArgs args, ChartDrawingGroup group, string item_name) =>
	ChartDrawingItem result = na 
	if group.current_drawings.size() > 0 
		for i = group.current_drawings.size() - 1 to 0 
			ChartDrawingItem current_item = group.current_drawings.get(i)
			if current_item.name == item_name 
				result := current_item 
				break 
	result 
 
helper_createAndAdd_ChartDrawingGroup(ChartDrawingArgs args, string group_name) =>
	ChartDrawingGroup group = ChartDrawingGroup.new()
	group.name := group_name 
	group.finished_drawings := array.new<ChartDrawingItem>() 
	group.current_drawings := array.new<ChartDrawingItem>()
	args.groups.push(group)
	group 

helper_createAndAdd_ChartDrawingItem(ChartDrawingArgs args, ChartDrawingGroup group, string item_name) =>
	ChartDrawingItem item = ChartDrawingItem.new() 
	item.name := item_name 
	group.current_drawings.push(item)
	item 
	
helper_removeCurrentChartDrawingItemByName(ChartDrawingArgs args, ChartDrawingGroup group, string item_name) =>
	if group.current_drawings.size() > 0
		for i = group.current_drawings.size() - 1 to 0 
			if group.current_drawings.get(i).name == item_name 
				group.current_drawings.remove(i)
				break //assumes no duplicates


helper_ChartDrawingLibrary_undrawBox(ChartDrawingArgs args, ChartDrawingBox chart_box) =>
	//delete the box
	if not na(chart_box.tv_box_item)
		chart_box.tv_box_item.delete()
		chart_box.tv_box_item := na 
	//delete the horizontal lines 
	if not na(chart_box.horizontal_lines)
		if chart_box.horizontal_lines.size() > 0 
			for i = chart_box.horizontal_lines.size() - 1 to 0 
				ChartDrawingHorizontalLine current_line = chart_box.horizontal_lines.get(i)
				if not na(current_line.tv_line_item)
					current_line.tv_line_item.delete()
					current_line.tv_line_item := na 

				

helper_undrawChartDrawingItem(ChartDrawingArgs args, ChartDrawingItem item) =>
	//delete chart box if it exists
	if not na(item.chart_box)
		helper_ChartDrawingLibrary_undrawBox(args, item.chart_box)

	//check for labels 
	if not na(item.chart_label)
		if not na(item.chart_label.tv_label_item)
			item.chart_label.tv_label_item.delete()
			item.chart_label.tv_label_item := na 

helper_ChartDrawingLibrary_drawChartHorizontalLine(ChartDrawingArgs args, ChartDrawingHorizontalLine chart_line) =>
	if na(chart_line.tv_line_item)
		chart_line.tv_line_item := line.new(x1 = chart_line.left_x, x2 = chart_line.right_x, y1 = chart_line.price, y2 = chart_line.price, color = chart_line.line_color, style = line.style_solid, width = 2)
helper_ChartDrawingLibrary_drawChartBox(ChartDrawingArgs args, ChartDrawingBox chart_box) =>
	if na(chart_box.tv_box_item)
		chart_box.tv_box_item := box.new(left = chart_box.left_bar_index,right = chart_box.right_bar_index,top = chart_box.top_price, bottom = chart_box.bottom_price, bgcolor = chart_box.box_color, border_color = chart_box.border_color)
	//draw lines 
	if chart_box.horizontal_lines.size() > 0 
		for i = chart_box.horizontal_lines.size() - 1 to 0 
			ChartDrawingHorizontalLine current_line = chart_box.horizontal_lines.get(i)
			helper_ChartDrawingLibrary_drawChartHorizontalLine(args, current_line)



helper_drawChartDrawingItem(ChartDrawingArgs args, ChartDrawingItem item) =>
	//chart box 
	if not na(item.chart_box)
		ChartDrawingBox chart_box = item.chart_box
		helper_ChartDrawingLibrary_drawChartBox(args, chart_box)

	if not na(item.chart_label)
		ChartDrawingLabel chart_label = item.chart_label
		if na(chart_label.tv_label_item)
			chart_label.tv_label_item := label.new(x = chart_label.bar_index_x, y = chart_label.price_y, text = chart_label.label_text)	


ChartDrawingLibrary_UpdateDrawing(ChartDrawingArgs args, string group_name, string item_name, ChartDrawingBox chart_box = na, ChartDrawingLabel chart_label = na) => 
	ChartDrawingGroup group = helper_getChartDrawingGroupByName(args, group_name)
	// add the group if it doesn't already exist
	if na(group)
		group := helper_createAndAdd_ChartDrawingGroup(args, group_name)

	//add the item if it doesn't already exist
	ChartDrawingItem item = helper_getCurrentChartDrawingItemByName(args, group, item_name)
	if na(item)
		item := helper_createAndAdd_ChartDrawingItem(args, group, item_name)
		
	//undraw the previous drawing before we draw the new one 
	helper_undrawChartDrawingItem(args, item)

	//update the new parts of the drawing 
	item.chart_box := chart_box 
	item.chart_label := chart_label

	//draw the new box
	helper_drawChartDrawingItem(args, item)

	
helper_ChartDrawingLibrary_addFinishedDrawing(ChartDrawingArgs args, ChartDrawingItem item, ChartDrawingGroup group) =>
	group.finished_drawings.push(item)
	//check if above max 
	if group.finished_drawings.size() > group.max_boxes_in_group
		group.finished_drawings.remove(0)//remove first item

//returns 0 on success, 1 on error
ChartDrawingLibrary_FinishDrawing(ChartDrawingArgs args, string group_name, string item_name) => 
	int return_code = 0
	ChartDrawingGroup group = helper_getChartDrawingGroupByName(args, group_name)
	ChartDrawingItem item = na
	// find if item exists 
	if not na(group)
		item := helper_getCurrentChartDrawingItemByName(args, group, item_name)
	if not na(item)
		//assumes the box is already drawn 
		helper_removeCurrentChartDrawingItemByName(args, group, item.name)
		helper_ChartDrawingLibrary_addFinishedDrawing(args = args, item = item, group = group)
		return_code := 0
	else
		//we should not reach here this is an error
		return_code := 1
	return_code 



ChartDrawingLibrary_CancelDrawing(ChartDrawingArgs args, string group_name, string item_name) => 
	int return_code = 0
	ChartDrawingGroup group = helper_getChartDrawingGroupByName(args, group_name)
	ChartDrawingItem item = na
	// find if item exists 
	if not na(group)
		item := helper_getCurrentChartDrawingItemByName(args, group, item_name)
	if not na(item)
		//delete the drawing 
		item.chart_box.tv_box_item.delete()
		helper_removeCurrentChartDrawingItemByName(args, group, item.name)
		return_code := 0
	else
		//we should not reach here this is an error
		return_code := 1
	return_code 


ChartDrawingLibrary_createChartDrawingBox(ChartDrawingArgs args, float top_price, float bottom_price, int left_bar_index, int right_bar_index, color bg_color, color border_color) =>
	ChartDrawingBox my_box = ChartDrawingBox.new()
	my_box.top_price := top_price 
	my_box.bottom_price := bottom_price 
	my_box.left_bar_index := left_bar_index 
	my_box.right_bar_index := right_bar_index
	my_box.box_color := bg_color 
	my_box.border_color := border_color
	my_box.horizontal_lines := array.new<ChartDrawingHorizontalLine>()

	my_box //return the box 

ChartDrawingLibrary_addHorizontalLineToChartDrawingBox(ChartDrawingArgs args, ChartDrawingBox chart_box, float line_price, bool solid_line) =>
	ChartDrawingHorizontalLine my_line = ChartDrawingHorizontalLine.new()
	my_line.left_x := chart_box.left_bar_index
	my_line.right_x := chart_box.right_bar_index
	my_line.price := line_price 
	my_line.solid_line := solid_line 
	chart_box.horizontal_lines.push(my_line)

ChartDrawingLibrary_createChartDrawingLabel(ChartDrawingArgs args, string label_text, int bar_index_x, float price_y, color label_color = na) =>
	ChartDrawingLabel my_label = ChartDrawingLabel.new()
	my_label.bar_index_x := bar_index_x 
	my_label.price_y := price_y 
	my_label.label_color := label_color 
	my_label.label_text := label_text 
	my_label 



	

// === Libraries/MultiTimeFrameLibrary.pine ===


type TimeFrameCandleDebugInfo
    int first_bar_index = 0
    int last_bar_index = 0
helper_MultiTimeFrameLibrary_copyTimeFrameCandleDebugInfo(TimeFrameCandleDebugInfo source, TimeFrameCandleDebugInfo destination) =>
    destination.first_bar_index := source.first_bar_index
    destination.last_bar_index := source.last_bar_index

type TimeFrameCandle
    float high_price = 0 
    float low_price = 0
    float open_price = 0 
    float close_price = 0 
    int timeframe = 0 //in minutes
    int bar_index_in_own_timeframe = 0
    bool is_finished = false 
    TimeFrameCandleDebugInfo debug_info = na
MultiTimeFrameLibrary_copyTimeFrameCandle(TimeFrameCandle source, TimeFrameCandle destination) =>
    destination.high_price := source.high_price
    destination.low_price := source.low_price
    destination.open_price := source.open_price
    destination.close_price := source.close_price
    destination.timeframe := source.timeframe
    destination.bar_index_in_own_timeframe := source.bar_index_in_own_timeframe
    destination.is_finished := source.is_finished

    // Ensure debug_info is allocated if not already
    if na(destination.debug_info)
        destination.debug_info := TimeFrameCandleDebugInfo.new()

    helper_MultiTimeFrameLibrary_copyTimeFrameCandleDebugInfo(source.debug_info, destination.debug_info)

type MultiTimeFrameLibraryDebuggingInfo
    bool debugger_enabled = true 
    array<bool> should_print_timeframe = na
    ChartDrawingArgs chart_drawing_library_args = na 
    float candle_transparency_level = 75 //0 to 100
    bool draw_all_candles = false 
create_MuliTimeFrameLibraryDebuggingInfo() =>
    MultiTimeFrameLibraryDebuggingInfo debugger = MultiTimeFrameLibraryDebuggingInfo.new() 
    debugger.should_print_timeframe := array.new<bool>()
    debugger.chart_drawing_library_args := ChartDrawingLibrary_createChartDrawingArgs()
    debugger
    
type MultiTimeFrameLibraryOutput 
    bool something_has_changed = false 
    array<bool> timeframe_candle_has_changed = na
    array<TimeFrameCandle> current_candles = na
create_MultiTimeFrameLibraryOutput() =>
    MultiTimeFrameLibraryOutput output = MultiTimeFrameLibraryOutput.new()
    output.timeframe_candle_has_changed := array.new<bool>() 
    output.current_candles := array.new<TimeFrameCandle>()
    output
type MultiTimeFrameLibraryArgs
    array<int> time_frames = na 
    int lowest_time_frame = 1 
    array<int> remaining_time_until_update = na
    array<int> last_timeframe_bar_index = na 
    MultiTimeFrameLibraryDebuggingInfo debugger = na
    MultiTimeFrameLibraryOutput output = na
create_MultiTimeFrameLibraryArgs() =>
    MultiTimeFrameLibraryArgs args = MultiTimeFrameLibraryArgs.new()
    args.time_frames := array.new<int>()
    args.remaining_time_until_update := array.new<int>()
    args.last_timeframe_bar_index := array.new<int>()
    args.current_candles := array.new<TimeFrameCandle>()
    args.debugger := create_MuliTimeFrameLibraryDebuggingInfo()
    args.output := create_MultiTimeFrameLibraryOutput()
    args 


//returns -1 it not in array
helper_getTimeFrameIndex(MultiTimeFrameLibraryArgs args, int timeframe)=>
    int result = -1
    if args.time_frames.size() > 0 
        for i = args.time_frames.size() -1 to 0
            int current_time_frame = args.time_frames.get(i)
            if current_time_frame == timeframe
                result := i 
                break 
    result 

MultiTimeFrameLibraryDebugger_toggleDrawHigherTimeFrameCandles(MultiTimeFrameLibraryArgs args, int timeframe, bool value) =>
    int time_frame_index = helper_getTimeFrameIndex(args, timeframe)
    args.debugger.should_print_timeframe.set(time_frame_index, value)




MultiTimeFrameLibrary_keepTrackofTimeFrame(MultiTimeFrameLibraryArgs args, int minutes) =>
    //make sure it doesnt already exist 
    if helper_getTimeFrameIndex(args, minutes) < 0
        args.time_frames.push(minutes)
        args.remaining_time_until_update.push(-1) //mark uninitialized 
        args.last_timeframe_bar_index.push(-1)
        args.output.current_candles.push(na)
        
        //optional debugging / drawing 
        if args.debugger.debugger_enabled
            args.debugger.should_print_timeframe.push(false)




MultiTimeFrameLibrary_getTimeframeCandle(MultiTimeFrameLibraryArgs args, int minutes) =>
    TimeFrameCandle candle = TimeFrameCandle.new()

    // Convert to TradingView-compatible timeframe string
    string tf_str = str.tostring(minutes)

    // Retrieve HTF data and bar confirmation status
    [o, h, l, c, barIndex, isConfirmed] = request.security(syminfo.tickerid, tf_str, [open, high, low, close, bar_index, barstate.isconfirmed])

    // Fill the candle struct
    candle.high_price := h
    candle.low_price := l
    candle.open_price := o 
    candle.close_price := c 
    candle.timeframe := minutes
    candle.bar_index_in_own_timeframe := barIndex  // This is LTF bar_index; it will be shared across multiple 1m bars
    candle.is_finished := isConfirmed

    if args.debugger.debugger_enabled
        candle.debug_info := TimeFrameCandleDebugInfo.new()
    candle

helper_MultiTimeFrameLibrary_createBoxFromCandle(MultiTimeFrameLibraryArgs args, TimeFrameCandle candle, bool candle_body) =>

    int candle_timeframe = candle.timeframe 
    int candle_timeframe_index = helper_getTimeFrameIndex(args, candle_timeframe)
    TimeFrameCandleDebugInfo candle_debug_info = candle.debug_info

    ChartDrawingBox chart_box = na 
    if candle_body
        bool is_green = candle.close_price >= candle.open_price 
        color candle_base_color = is_green ? color.green : color.red 
        color candle_color = color.new(candle_base_color, args.debugger.candle_transparency_level)
        float top_price = math.max(candle.open_price, candle.close_price)
        float bottom_price = math.min(candle.open_price, candle.close_price)
        chart_box := ChartDrawingLibrary_createChartDrawingBox(args = args.debugger.chart_drawing_library_args , top_price = top_price, bottom_price = bottom_price, left_bar_index = candle_debug_info.first_bar_index, right_bar_index = candle_debug_info.last_bar_index, bg_color = candle_color , border_color = candle_color)
    else
        bool is_green = candle.close_price >= candle.open_price 
        color candle_base_color = is_green ? color.green : color.red 
        color candle_color = color.new(candle_base_color, 0)
        float top_price = candle.high_price
        float bottom_price = candle.low_price
        chart_box := ChartDrawingLibrary_createChartDrawingBox(args = args.debugger.chart_drawing_library_args , top_price = top_price, bottom_price = bottom_price, left_bar_index = candle_debug_info.first_bar_index, right_bar_index = candle_debug_info.last_bar_index, bg_color = color.new(color.red, 100) , border_color = candle_color)

    
    chart_box 

            

            
MultiTimeFrameLibraryDebugger_drawCandle(MultiTimeFrameLibraryArgs args, TimeFrameCandle current_candle) => 
    int timeframe = current_candle.timeframe 
    ChartDrawingBox chart_box = helper_MultiTimeFrameLibrary_createBoxFromCandle(args, current_candle, true )
    ChartDrawingBox outline_box = helper_MultiTimeFrameLibrary_createBoxFromCandle(args, current_candle, false)
    string chart_drawing_group_name = "MultiTimeFrame_" + str.tostring(timeframe)
    string chart_drawing_item_name = str.tostring(current_candle.bar_index_in_own_timeframe)
    string chart_drawing_outline_item_name = str.tostring(current_candle.bar_index_in_own_timeframe) + "_outline"
    ChartDrawingLibrary_UpdateDrawing(args = args.debugger.chart_drawing_library_args, group_name = chart_drawing_group_name, item_name = chart_drawing_item_name, chart_box = chart_box)
    ChartDrawingLibrary_UpdateDrawing(args = args.debugger.chart_drawing_library_args, group_name = chart_drawing_group_name, item_name = chart_drawing_outline_item_name, chart_box = outline_box)
    ChartDrawingLibrary_FinishDrawing(args = args.debugger.chart_drawing_library_args, group_name = chart_drawing_group_name, item_name = chart_drawing_item_name)
    ChartDrawingLibrary_FinishDrawing(args = args.debugger.chart_drawing_library_args, group_name = chart_drawing_group_name, item_name = chart_drawing_outline_item_name)


MultiTimeFrameLibrary_update(MultiTimeFrameLibraryArgs args) =>
    args.something_has_changed := false 
    if args.remaining_time_until_update.size() > 0 
        for i = args.remaining_time_until_update.size() - 1 to 0 
            //check if we have a new candle index 
            int timeframe = args.time_frames.get(i)
            string tf_str = str.tostring(timeframe)
            [timeframe_bar_index] = request.security(syminfo.tickerid, tf_str, [bar_index])
            int prev_bar_index = args.last_timeframe_bar_index.get(i)

            if timeframe_bar_index > prev_bar_index
                args.something_has_changed := true
                //update previous bar index 
                args.last_timeframe_bar_index.set(i, timeframe_bar_index)
                //reset the count 
                args.remaining_time_until_update.set(i, timeframe)
                TimeFrameCandle new_candle = MultiTimeFrameLibrary_getTimeframeCandle(args, timeframe)
                

                //optionally draw the new candle
                if args.debugger.debugger_enabled 
                    TimeFrameCandle current_candle = args.output.current_candles.get(i)
                    int candle_start_point = bar_index
                    if not na(current_candle)
                        candle_start_point := current_candle.debug_info.last_bar_index
                    new_candle.debug_info.last_bar_index := bar_index 
                    new_candle.debug_info.first_bar_index := candle_start_point + 1
                    if args.debugger.draw_all_candles == true
                        MultiTimeFrameLibraryDebugger_drawCandle(args, new_candle)

                args.output.current_candles.set(i, new_candle)






MultiTimeFrameLibrary_isHigherTimeFrameCandleFinished(MultiTimeFrameLibraryArgs args, int minutes) =>
    int timeframe_index = helper_getTimeFrameIndex(args, minutes)
    args.remaining_time_until_update.get(timeframe_index) == 0

                
                

// === Libraries/TradeManagerLibrary.pine ===
//@version=6
// === ENUM DEFINITIONS ===

// Direction of the trade
enum Direction
    Long    // Buy-side setup
    Short   // Sell-side setup
stringify_Direction(Direction dir) =>
    string result = ""
    if dir == Direction.Long
        result := "Long"
    else if dir == Direction.Short
        result := "Short"
    result


// Order type (reserved for future use; not used in core logic)
enum OrderType
    Limit
    Stop
stringify_OrderType(OrderType t) =>
    string result = ""
    if t == OrderType.Limit
        result := "Limit"
    else if t == OrderType.Stop
        result := "Stop"
    result


// Current state of a trade
enum EntryState
    Placed         // Waiting to be triggered
    Entered        // Actively in a trade
    Invalidated    // Stopped before entry (e.g. stop hit first)
    Success        // Target hit
    Loss           // Stop loss hit
    Breakeven      // got stopped out at breakeven
stringify_EntryState(EntryState s) =>
    string result = ""
    if s == EntryState.Placed
        result := "Placed"
    else if s == EntryState.Entered
        result := "Entered"
    else if s == EntryState.Invalidated
        result := "Invalidated"
    else if s == EntryState.Success
        result := "Success"
    else if s == EntryState.Loss
        result := "Loss"
    else if s == EntryState.Breakeven
        result := "Breakeven"
    result


type EntryDebugData
    bool should_draw = true //draw with the debugger
    bool is_drawn_on_screen = false
    string drawing_group_name = na 
    string drawing_item_name = na
    bool drawing_finished = false
    float transparency_level = 75 // 100 = fully transparent, 0 = fully colored 
// === ENTRY STRUCTURE ===
type EntryAdditionalData
    float original_stopLossPrice = 0
    float original_targetPrice = 0

    int placed_on_index = 0
    int entered_on_index = 0 
    int invalidated_on_index = 0 
    int lost_on_index = 0
    int won_on_index = 0
    int breakeven_on_index = 0

    string trade_id = na //for strategy tester 
    EntryDebugData debug_data = na
helper_createEntryAdditionalData() => 
    EntryAdditionalData additional_data = EntryAdditionalData.new()
    additional_data.debug_data := EntryDebugData.new()
    additional_data
type TradeExitInfo 
    bool will_break_even = false
    bool is_currently_break_even = false
    int breakeven_on_n = 1 //break even on the n'th candle after entry, only 1 and higher is currently supported, any other value is considered break_even disabled
// Represents a single trade
type Entry
    Direction dir              // Trade direction
    OrderType orderType        // Entry type (not currently used in logic)
    float entryPrice           // Entry level
    float stopLossPrice        // Stop loss level
    float targetPrice          // Target level
    float risk_reward_ratio
    EntryState state           // Current status of this trade
    int num_shares             // Optional: share/contract size (default = 1)
    int index                  // bar index (needed to not process the hitting of the stop loss on the actual entry candle)
    EntryAdditionalData additional_data
    TradeExitInfo trade_exit_info

stringify_Entry(Entry e) =>
    string result = "ENTRY (index = " + str.tostring(e.index) + " )\n"
    result += "\tDir: " + stringify_Direction(e.dir) + "\n"
    result += "\tType: " + stringify_OrderType(e.orderType) + "\n"
    result += "\tEntry: " + str.tostring(e.entryPrice) + "\n"
    result += "\tSL: " + str.tostring(e.stopLossPrice) + "\n"
    result += "\tTP: " + str.tostring(e.targetPrice) + "\n"
    result += "\tRR: " + str.tostring(e.risk_reward_ratio) + "\n"
    result += "\tState: " + stringify_EntryState(e.state) + "\n"
    result += "\tSize: " + str.tostring(e.num_shares)
    result



calculate_RR_ratio_based_on_prices(float entry_price, float stop_loss_price, float target_price) =>
    float distance = entry_price - stop_loss_price 
    float distance_to_target = target_price - entry_price
    float RR = distance_to_target / distance
    RR

calculate_target_based_on_RR_ratio(float entry_price, float stop_loss_price, float RR_ratio) =>
    float distance = entry_price - stop_loss_price
    float distance_to_target = distance * RR_ratio 
    float target = entry_price + distance_to_target
    target


// Creates a new Entry instance with default state
helper_createEntry(Direction dir, OrderType orderType, float entryPrice, float stopLossPrice, int index) =>
    Entry my_entry = Entry.new() 
    my_entry.dir := dir 
    my_entry.orderType := orderType 
    my_entry.entryPrice := entryPrice
    my_entry.stopLossPrice := stopLossPrice
    my_entry.state := EntryState.Placed
    my_entry.num_shares := 1 
    my_entry.index := index
    my_entry.additional_data := helper_createEntryAdditionalData()
    my_entry.additional_data.placed_on_index := bar_index 
    my_entry.trade_exit_info := TradeExitInfo.new()
    my_entry
helper_fillEntryAdditionalData(Entry entry) =>
    entry.additional_data.original_stopLossPrice := entry.stopLossPrice
    entry.additional_data.original_targetPrice := entry.targetPrice 



create_Entry_with_target_price(Direction dir, OrderType orderType, float entryPrice, float stopLossPrice, float targetPrice, int index) =>
    Entry my_entry = helper_createEntry(dir = dir, orderType = orderType, entryPrice = entryPrice, stopLossPrice = stopLossPrice, index = index)
    my_entry.targetPrice := targetPrice
    //calculate RR
    my_entry.risk_reward_ratio := calculate_RR_ratio_based_on_prices(entryPrice, stopLossPrice, targetPrice)
    helper_fillEntryAdditionalData(my_entry)
    my_entry

create_Entry_with_target_RR(Direction dir, OrderType orderType, float entryPrice, float stopLossPrice, float targetRR, int index) =>
    Entry my_entry = helper_createEntry(dir = dir, orderType = orderType, entryPrice = entryPrice, stopLossPrice = stopLossPrice, index = index)
    my_entry.risk_reward_ratio := targetRR
    //calculate RR
    my_entry.targetPrice := calculate_target_based_on_RR_ratio(entryPrice,stopLossPrice,targetRR)
    helper_fillEntryAdditionalData(my_entry)
    my_entry

// === TRADE WRAPPER STRUCTURE ===

// keeps track of total profit, and possibly other metrics in the future 
type TradeDataCollector
    int num_trades_entered = 0
    int num_trades_won = 0 
    int num_trades_lost = 0
    int num_trades_breakeven = 0
    float total_profit_USD = 0 
    float total_profit_R = 0
stringify_TradeDataCollector(TradeDataCollector data) =>
    string result = ""
    result += "Trades Entered: " + str.tostring(data.num_trades_entered) + "\n"
    result += "Trades Won: " + str.tostring(data.num_trades_won) + "\n"
    result += "Trades Lost: " + str.tostring(data.num_trades_lost) + "\n"
    result += "Num Trades Breakeven: " + str.tostring(data.num_trades_breakeven) + "\n"
    result += "Total Profit (USD): " + str.tostring(data.total_profit_USD) + "\n"
    result += "Total Profit (R): " + str.tostring(data.total_profit_R)
    result


type InstrumentInfo
    float tick_value_in_USD = 0
    float USD_made_per_tick = 0
create_InstrumentInfo() =>
    InstrumentInfo info = InstrumentInfo.new() 
    info.tick_value_in_USD := syminfo.mintick
    info.USD_made_per_tick := (syminfo.pointvalue * syminfo.mintick)
    info
stringify_InstrumentInfo(InstrumentInfo info) => 
    string my_string = "InstrumentInfo: "
    my_string += "\ttick_value_in_USD = " + str.tostring(info. tick_value_in_USD) + "\n"
    my_string += "\tUSD_made_per_tick = " + str.tostring(info.USD_made_per_tick)
    my_string

type TradeLibraryDebuggingInfo
    bool enable_debugging = true
    ChartDrawingArgs chart_drawing_library_args = na 
    string group_name = "TradeLibraryEntries"
    color winning_trade_color = color.green
    color losing_trade_color = color.red 
    color breakeven_trade_color = color.blue
    color border_color_in_progress = color.blue
    color border_color_finished = color.black

    bool print_active_trades_when_something_changes = false
    bool print_trade_data_on_last_bar = true
helper_createTradeLibraryDebuggingInfo()=>
    TradeLibraryDebuggingInfo debugger = TradeLibraryDebuggingInfo.new()
    debugger.chart_drawing_library_args := ChartDrawingLibrary_createChartDrawingArgs()
    debugger
    
    
type TradeLibraryArgsParameters
    bool pyramiding_allowed = false 
// A container to manage multiple entries (i.e. a portfolio of trades)
type TradeLibraryArgs
    TradeLibraryArgsParameters parameters = na 
    array<Entry> entry_array = na
    TradeDataCollector data_collector = na
    InstrumentInfo instrument_info = na
    bool something_has_changed = false
    TradeLibraryDebuggingInfo debugger = na

// Initializes a new TradeLibraryArgs instance with an empty trade array
create_TradeLibraryArgs() =>
    TradeLibraryArgs args = TradeLibraryArgs.new()
    args.entry_array := array.new<Entry>()
    args.data_collector := TradeDataCollector.new()
    args.instrument_info := create_InstrumentInfo()
    args.parameters := TradeLibraryArgsParameters.new()
    args.debugger := helper_createTradeLibraryDebuggingInfo()
    args

stringify_all_trades(TradeLibraryArgs args) =>
    string my_text = na
    array<Entry> entries = args.entry_array 
    if entries.size() > 0 
        my_text := ""
        for i = entries.size() - 1 to 0 
            Entry entry = entries.get(i)
            my_text += stringify_Entry(entry) + "\n"
    my_text 

is_long_already_open(TradeLibraryArgs args) =>
    bool already_open = false 
    if args.entry_array.size() > 0 
        for i = args.entry_array.size() - 1 to 0 
            Entry entry = args.entry_array.get(i)
            if (entry.state == EntryState.Entered) and (entry.dir == Direction.Long)
                already_open := true 
                break 
    already_open 


is_short_already_open(TradeLibraryArgs args) =>
    bool already_open = false 
    if args.entry_array.size() > 0 
        for i = args.entry_array.size() - 1 to 0 
            Entry entry = args.entry_array.get(i)
            if (entry.state == EntryState.Entered) and (entry.dir == Direction.Short)
                already_open := true 
                break 
    already_open 

TradeManagerLibrary_setEntryBreakeven(TradeLibraryArgs args, Entry entry, int breakeven_on_n) =>
    entry.trade_exit_info.will_break_even := true 
    entry.trade_exit_info.breakeven_on_n := breakeven_on_n
    entry.trade_exit_info.is_currently_break_even := false
// Adds a trade entry to the array
place_trade(TradeLibraryArgs args, Entry entry) =>
    bool can_place = true 
    if args.parameters.pyramiding_allowed == false
        bool is_long = entry.dir == Direction.Long 
        bool is_short = entry.dir == Direction.Short 
        bool already_exists = false 
        if is_long 
            already_exists := is_long_already_open(args)
        else if is_short 
            already_exists := is_short_already_open(args)
        if already_exists
            can_place := false 
    if can_place 
        args.entry_array.push(entry)
    


get_entry_win_amount(TradeLibraryArgs args, Entry entry) =>
    float usd_win_distance = math.abs(entry.entryPrice - entry.targetPrice)
    int usd_win_distance_ticks = math.round(usd_win_distance / args.instrument_info.tick_value_in_USD)
    float win_in_USD = (usd_win_distance_ticks * args.instrument_info.USD_made_per_tick) * entry.num_shares
    win_in_USD

get_entry_loss_amount(TradeLibraryArgs args, Entry entry) => 
    float usd_loss_distance = math.abs(entry.entryPrice - entry.stopLossPrice)
    int usd_loss_distance_ticks = math.round(usd_loss_distance / args.instrument_info.tick_value_in_USD)
    float loss_in_USD = (usd_loss_distance_ticks * args.instrument_info.USD_made_per_tick) * entry.num_shares
    loss_in_USD

// === PER-CANDLE PROCESSING ===

process_trade_entered(TradeLibraryArgs args, Entry entry) =>
    entry.state := EntryState.Entered
    entry.additional_data.entered_on_index := bar_index 
    args.data_collector.num_trades_entered += 1
    args.something_has_changed := true 

process_trade_invalidated(TradeLibraryArgs args, Entry entry) =>
    entry.state := EntryState.Invalidated
    entry.additional_data.invalidated_on_index := bar_index
    args.something_has_changed := true

helper_TradeManagerLibrary_processTradeBreakeven(TradeLibraryArgs args, Entry entry) =>
    entry.state := EntryState.Breakeven
    args.data_collector.num_trades_breakeven += 1
    entry.additional_data.breakeven_on_index := bar_index 
    args.something_has_changed := true 

//call when price hits stoploss (breakeven, or true stoploss)
helper_TradeManagerLibrary_processTradeStopLoss(TradeLibraryArgs args, Entry entry) =>
    if entry.trade_exit_info.is_currently_break_even and (entry.entryPrice == entry.stopLossPrice)
        helper_TradeManagerLibrary_processTradeBreakeven(args, entry)
    else
        entry.state := EntryState.Loss
        args.data_collector.total_profit_R -= 1
        args.data_collector.num_trades_lost += 1
        entry.additional_data.lost_on_index := bar_index
        args.something_has_changed := true 
        args.data_collector.total_profit_USD -= get_entry_loss_amount(args, entry)
    0 //dummy return value 



helper_TradeManagerLibrary_processTradeTargetHit(TradeLibraryArgs args, Entry entry) =>
    if entry.trade_exit_info.is_currently_break_even and (entry.entryPrice == entry.targetPrice)
        helper_TradeManagerLibrary_processTradeBreakeven(args, entry)
    else
        entry.state := EntryState.Success
        args.data_collector.total_profit_R += entry.risk_reward_ratio
        args.data_collector.num_trades_won += 1
        entry.additional_data.won_on_index := bar_index 
        args.something_has_changed := true    
        args.data_collector.total_profit_USD += get_entry_win_amount(args, entry)
    0//dummy return value


//sets the group and item names 
helper_TradeManagerLibraryDebugger_setEntryDrawingNames(TradeLibraryArgs args, Entry entry) =>
    entry.additional_data.debug_data.drawing_group_name := args.debugger.group_name
    entry.additional_data.debug_data.drawing_item_name := stringify_Entry(entry)

//this is the only function that reads or writes the entries debugging info
TradeManagerLibraryDebugger_processAndDrawEntry(TradeLibraryArgs args, Entry entry) =>
    EntryDebugData entry_debug_info = entry.additional_data.debug_data
    //finish the drawing if we just won or lost the trade
    bool should_finish_drawing = (entry.state == EntryState.Success) or (entry.state == EntryState.Loss) or (entry.state == EntryState.Breakeven)
    should_finish_drawing := should_finish_drawing and (not entry_debug_info.drawing_finished) 
    //cancel the drawing if the entry got invalidated
    bool should_cancel_drawing = (entry.state == EntryState.Invalidated)
    //update drawing if we are mid trade or if we just placed the trade
    bool should_update_drawing = (entry.state == EntryState.Entered) or ((entry.state == EntryState.Placed) and not entry_debug_info.is_drawn_on_screen)
    //set the debugging drawing group and item names 
    if na(entry.additional_data.debug_data.drawing_item_name)
        helper_TradeManagerLibraryDebugger_setEntryDrawingNames(args, entry)
    string drawing_group_name = entry.additional_data.debug_data.drawing_group_name
    string drawing_item_name = entry.additional_data.debug_data.drawing_item_name
    ChartDrawingArgs chart_drawing_library_args = args.debugger.chart_drawing_library_args
    // cancel drawing
    if should_cancel_drawing
        ChartDrawingLibrary_CancelDrawing(chart_drawing_library_args, drawing_group_name, drawing_item_name)
    // update drawing (update one last time if finished)
    if should_update_drawing or should_finish_drawing
        //determine the box boundaries and colors 
        bool is_winning = false 
        bool is_trade_open = false 
        bool is_breakeven = false 
        bool is_long = entry.dir == Direction.Long 
        bool is_short = entry.dir == Direction.Short
        float current_price = close
        int left_bar_index = entry.index 
        int right_bar_index = 0 
        float top_price = math.max(entry.additional_data.original_targetPrice, entry.additional_data.original_stopLossPrice)
        float bottom_price = math.min(entry.additional_data.original_targetPrice, entry.additional_data.original_stopLossPrice)
        color box_color_base = na
        if entry.state == EntryState.Success
            is_winning := true 
            is_trade_open := false 
            right_bar_index := entry.additional_data.won_on_index
        else if entry.state == EntryState.Loss 
            is_winning := false 
            is_trade_open := false 
            right_bar_index := entry.additional_data.lost_on_index
        else if entry.state == EntryState.Entered
            is_winning := (is_long and current_price > entry.entryPrice) or (is_short and current_price < entry.entryPrice)
            is_trade_open := true 
            right_bar_index := bar_index
            top_price := math.max(entry.entryPrice, current_price)
            bottom_price := math.min(entry.entryPrice, current_price)
        else if entry.state == EntryState.Placed 
            is_trade_open := true 
            right_bar_index := bar_index + 1
            top_price := math.max(entry.entryPrice, entry.additional_data.original_stopLossPrice)
            bottom_price := math.min(entry.entryPrice, entry.additional_data.original_stopLossPrice)
        else if entry.state == EntryState.Breakeven 
            is_trade_open := false 
            right_bar_index := bar_index 
            top_price := math.max(entry.entryPrice, entry.additional_data.original_stopLossPrice)
            bottom_price := math.min(entry.entryPrice, entry.additional_data.original_stopLossPrice)
            box_color_base := args.debugger.breakeven_trade_color
        
        if na(box_color_base)
            box_color_base := is_winning ? args.debugger.winning_trade_color : args.debugger.losing_trade_color
        color box_color = color.new(box_color_base, entry_debug_info.transparency_level)
        color border_color = is_trade_open ? args.debugger.border_color_in_progress : args.debugger.border_color_finished
        //create and update the box 
        ChartDrawingBox chart_box = ChartDrawingLibrary_createChartDrawingBox(chart_drawing_library_args, top_price, bottom_price, left_bar_index, right_bar_index, box_color, border_color)
        ChartDrawingLibrary_UpdateDrawing(chart_drawing_library_args, drawing_group_name, drawing_item_name, chart_box = chart_box)
        entry_debug_info.is_drawn_on_screen := true 

    //Mark as finished if applicable
    if should_finish_drawing
        ChartDrawingLibrary_FinishDrawing(chart_drawing_library_args, drawing_group_name, drawing_item_name)
        entry_debug_info.drawing_finished := true


TradeManagerLibraryDebugger_updateDrawings(TradeLibraryArgs args) =>
    //draw the trades 
    if args.entry_array.size() > 0
        for i = args.entry_array.size() - 1 to 0
            Entry current_entry = args.entry_array.get(i)
            TradeManagerLibraryDebugger_processAndDrawEntry(args, current_entry)

    //print a label of all trade states if something changes  
    if args.debugger.print_active_trades_when_something_changes
        if args.something_has_changed
            string label_text = stringify_all_trades(args)
            string label_id = "print_active_trades_when_something_changes" + str.tostring(time)
            ChartDrawingLabel chart_label = ChartDrawingLibrary_createChartDrawingLabel(args = args.debugger.chart_drawing_library_args,label_text = label_text, bar_index_x = bar_index, price_y = high) 
            ChartDrawingLibrary_UpdateDrawing(args = args.debugger.chart_drawing_library_args,group_name = args.debugger.group_name, item_name = label_id, chart_label = chart_label)
            ChartDrawingLibrary_FinishDrawing(args = args.debugger.chart_drawing_library_args,group_name = args.debugger.group_name, item_name = label_id)
    
    //print the aggregated trade data at the end 
    if barstate.islast 
        if args.debugger.print_trade_data_on_last_bar
            string label_text = stringify_TradeDataCollector(args.data_collector)
            string label_id = "print_trade_data_on_last_bar" + str.tostring(time)
            ChartDrawingLabel chart_label = ChartDrawingLibrary_createChartDrawingLabel(args = args.debugger.chart_drawing_library_args,label_text = label_text, bar_index_x = bar_index, price_y = high) 
            ChartDrawingLibrary_UpdateDrawing(args = args.debugger.chart_drawing_library_args,group_name = args.debugger.group_name, item_name = label_id, chart_label = chart_label)
            ChartDrawingLibrary_FinishDrawing(args = args.debugger.chart_drawing_library_args,group_name = args.debugger.group_name, item_name = label_id)
    
//assumes that entry has breakeven set to true (make sure before function is called )
helper_TradeManagerLibrary_processCandleForEntryBreakeven(TradeLibraryArgs args, Entry entry) =>
    TradeExitInfo trade_exit_info = entry.trade_exit_info 
    //assumes entry.trade_exit_info.break_even = true 
    //assumes entry.state = Placed
    if not trade_exit_info.is_currently_break_even
        int num_candles_past_entry = bar_index - entry.additional_data.entered_on_index 
        bool should_be_breakeven = trade_exit_info.breakeven_on_n == num_candles_past_entry
        if should_be_breakeven
            //check if we are below or above price (determines if we are moving our stop loss or take profit to break even)
            float current_price = close 
            bool is_long = entry.dir == Direction.Long 
            bool is_short = entry.dir == Direction.Short
            bool is_winning = (is_long and current_price >= entry.entryPrice) or (is_short and current_price <= entry.entryPrice)
            trade_exit_info.is_currently_break_even := true 
            if is_winning
                entry.stopLossPrice := entry.entryPrice 
            else 
                entry.targetPrice := entry.entryPrice 





// Checks a single candle (high/low) against a single entry and updates its state
TradeManagerLibrary_processCandleForEntry(TradeLibraryArgs args, Entry entry, float candleHigh, float candleLow) =>
    //ignore if this is the same index
    if entry.index != bar_index

        //first set the breakeven if applicable because it can affect stoplosses / targets
        if entry.state == EntryState.Entered 
            if entry.trade_exit_info.will_break_even and  not entry.trade_exit_info.is_currently_break_even
                helper_TradeManagerLibrary_processCandleForEntryBreakeven(args, entry)

        isLong = entry.dir == Direction.Long
        isShort = entry.dir == Direction.Short
        //Todo add worst case assumptions for stop orders vs limit orders
        crossedEntry = candleLow <= entry.entryPrice and entry.entryPrice <= candleHigh
        crossedTarget = candleLow < entry.targetPrice and entry.targetPrice < candleHigh
        completely_passed_target = (isLong and candleLow > entry.targetPrice) or (isShort and candleHigh < entry.targetPrice)
        touchedStop = (isLong and candleLow <= entry.stopLossPrice) or (isShort and candleHigh >= entry.stopLossPrice)
        if entry.state == EntryState.Placed
            if crossedEntry
                process_trade_entered(args, entry)
            else if touchedStop
                process_trade_invalidated(args, entry)
        if entry.state == EntryState.Entered
            if touchedStop
                helper_TradeManagerLibrary_processTradeStopLoss(args, entry) //handles breakeven case
            else if crossedTarget or completely_passed_target
                helper_TradeManagerLibrary_processTradeTargetHit(args, entry)




// Removes trades that are no longer active (Invalidated, Success, or Loss)
remove_all_finished_trades(TradeLibraryArgs args) =>
    if args.entry_array.size() > 0
        for i = args.entry_array.size() - 1 to 0
            Entry current_entry = args.entry_array.get(i)
            bool finished = false
            if current_entry.state == EntryState.Invalidated
                finished := true
            else if current_entry.state == EntryState.Loss
                finished := true
            else if current_entry.state == EntryState.Success
                finished := true
            else if current_entry.state == EntryState.Breakeven
                finished := true
            if finished
                args.entry_array.remove(i)

// Loops over all trades and processes them using the current candle's high/low
TradeManagerLibrary_process_candle(TradeLibraryArgs args) =>
    remove_all_finished_trades(args)
    args.something_has_changed := false 
    if args.entry_array.size() > 0
        for i = args.entry_array.size() - 1 to 0
            Entry current_entry = args.entry_array.get(i)
            TradeManagerLibrary_processCandleForEntry(args, current_entry, high, low)
    //optional debugging / drawing 
    if args.debugger.enable_debugging
        TradeManagerLibraryDebugger_updateDrawings(args)




        


// === Libraries/BooleanExpressionLibrary.pine ===
//@version=6
// === ENUMS ===

// Represents logical Boolean operators
enum BOOLEAN_OPERATOR
    AND     // Logical AND
    OR      // Logical OR
    NOT     // Logical NOT (unary)
	IS     // default 
is_BOOLEAN_OPERATOR_binary(BOOLEAN_OPERATOR op) =>
	bool result = false 
	if op == BOOLEAN_OPERATOR.AND
		result := true
	else if op == BOOLEAN_OPERATOR.OR
		result := true
	result


// === TYPES ===

// Struct for representing a Boolean expression node (base level or composite)
// - If `is_base_level_expression` is true, the node is a leaf with a fixed boolean value
// - Otherwise, it's a composite expression with an operator and children
type BooleanExpression
    string name = na // the name of the expression / condition 
    bool is_base_level_expression = false          // True if this node is a leaf
    bool base_level_expression = false             // Value for base-level expressions
    BooleanExpression left_expression = na         // Left child (required)
    BooleanExpression right_expression = na        // Right child (optional for NOT)
    BOOLEAN_OPERATOR operator = na                 // Operator applied to children
    bool evaluated_value = false                   // Cached evaluation result



// Creates a BooleanExpression struct with all required values
create_BooleanExpression(string name, bool is_base_level, bool base_level_val, BOOLEAN_OPERATOR operator, BooleanExpression left_val, BooleanExpression right_val) =>
    BooleanExpression expr = BooleanExpression.new(name, is_base_level, base_level_val, left_val, right_val, operator, false)
    expr

// Frame used to simulate recursive evaluation using an explicit stack
// Tracks whether children have been evaluated yet
type EvaluationFrame
    BooleanExpression node = na
    bool left_result = false
    bool right_result = false
    bool evaluated_left = false
    bool evaluated_right = false

// === MAIN EVALUATION FUNCTION ===

// Evaluates a BooleanExpression tree using a manual stack (non-recursive)
// Handles nested AND/OR/NOT logic in order, from bottom-up
// Caches result in node.evaluated_value and returns final result
evaluate_BooleanExpression(BooleanExpression expression) =>
    array<EvaluationFrame> stack = array.new<EvaluationFrame>()
    EvaluationFrame root = EvaluationFrame.new(expression, false, false, false, false)
    array.push(stack, root)
    bool final_result = false

    while array.size(stack) > 0
        EvaluationFrame frame = stack.pop()

        // Case 1: Base-level expression (leaf node)
        if frame.node.is_base_level_expression
            frame.node.evaluated_value := frame.node.base_level_expression

        // Case 2: Evaluate left side first
        else if not frame.evaluated_left
            EvaluationFrame left = EvaluationFrame.new(frame.node.left_expression, false, false, false, false)
            frame.evaluated_left := true
            array.push(stack, frame)
            array.push(stack, left)

        // Case 3: Evaluate right side (for binary ops only)
        else if is_BOOLEAN_OPERATOR_binary(frame.node.operator) and not frame.evaluated_right
            EvaluationFrame right = EvaluationFrame.new(frame.node.right_expression, false, false, false, false)
            frame.evaluated_right := true
            array.push(stack, frame)
            array.push(stack, right)

        // Case 4: Both children evaluated â€” now compute result
        else
            bool expression_result = false
            bool left_value = false
            bool right_value = false
            if frame.evaluated_left
                left_value := frame.node.left_expression.evaluated_value
            if frame.evaluated_right
                right_value := frame.node.right_expression.evaluated_value

            if frame.node.operator == BOOLEAN_OPERATOR.NOT
                expression_result := not left_value
			else if frame.node.operator == BOOLEAN_OPERATOR.IS
				expression_result := left_value
            else if frame.node.operator == BOOLEAN_OPERATOR.AND
                expression_result := left_value and right_value
            else if frame.node.operator == BOOLEAN_OPERATOR.OR
                expression_result := left_value or right_value

            frame.node.evaluated_value := expression_result

    final_result





// === Libraries/KeyLevelLibrary.pine ===
type KeyLevel
    string name = na 
    float current_value = na 

type KeyLevelLibraryArgs 
    array<KeyLevel> key_levels = na 

create_KeyLevelLibraryArgs() => 
    KeyLevelLibraryArgs args = KeyLevelLibraryArgs.new() 
    args.key_levels := array.new<KeyLevel>() 
    args


get_KeyLeveL_from_name(KeyLevelLibraryArgs args, string name) =>
    KeyLevel result = na 
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_key_level = args.key_levels.get(i)
            if current_key_level.name == name 
                result := current_key_level 
                break 
    result 

KeyLevelLibrary_updateKeyLevel(KeyLevelLibraryArgs args, string name, float value) => 
    KeyLevel level = get_KeyLeveL_from_name(args, name)
    //if it doesn't exist, add it 
    if na(level)
        level := KeyLevel.new()
        level.name := name 
        level.current_value := value 
        args.key_levels.push(level)
    else
        level.current_value := value 
    0//dummy return value


helper_isPriceTouchingKeyLevel(KeyLevel key_level) =>
    float price = key_level.current_value 
    (low <= price) and (high >= price)

KeyLevelLibrary_isPriceTouchingAnyKeyLevel(KeyLevelLibraryArgs args) =>
    bool result = false 
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_level = args.key_levels.get(i)
            if helper_isPriceTouchingKeyLevel(current_level)
                result := true 
                break 
    result 

KeyLevelLibrary_isPriceTouchingKeyLevel(KeyLevelLibraryArgs args, string name) => 
    bool result = false 
    KeyLevel level = get_KeyLeveL_from_name(args, name)
    if not na(level)
        result := helper_isPriceTouchingKeyLevel(level)
    result


//returns 0 if touching, positive if level is above price, negative if level below price
KeyLevelLibrary_getDistanceToKeyLevel(KeyLevel level) =>
    float distance = 0
    if helper_isPriceTouchingKeyLevel(level)
        distance := 0 
    else
        bool level_is_above_price = high < level.current_value
        bool level_is_below_price = not level_is_above_price
        if level_is_above_price 
            distance := level.current_value - high //should be positive
        else if level_is_below_price 
            distance := level.current_value - low //should be negative
    distance 

//returns 0 if touching (na if invalid level name), positive if level is above price, negative if level is below price 
KeyLevelLibrary_getDistanceToKeyLevelByName(KeyLevelLibraryArgs args, string name) =>
    float result = na
    KeyLevel level = get_KeyLeveL_from_name(args, name)
    if not na(level)
        result := KeyLevelLibrary_getDistanceToKeyLevel(level)
    result 



KeyLevelLibrary_getNearestKeyLevel(KeyLevelLibraryArgs args, bool ignore_levels_currently_touching) =>
    KeyLevel result = na
    float closest_distance = na
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_level = args.key_levels.get(i)
            float current_distance = KeyLevelLibrary_getDistanceToKeyLevel(current_level)
            if na(closest_distance)
                closest_distance := current_distance 
                result := current_level
            else
                if ignore_levels_currently_touching and (current_distance == 0)
                    continue 
                else if math.abs(current_distance) < math.abs(current_distance) 
                    closest_distance := current_distance
                    result := current_level 
    result
        

KeyLevelLibrary_getNearestKeyLevelLong(KeyLevelLibraryArgs args, bool ignore_levels_currently_touching) =>
    KeyLevel result = na
    float closest_distance = na
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_level = args.key_levels.get(i)
            float current_distance = KeyLevelLibrary_getDistanceToKeyLevel(current_level)
            if current_distance >= 0
                if na(closest_distance)
                    closest_distance := current_distance 
                    result := current_level
                else
                    if ignore_levels_currently_touching and (current_distance == 0)
                        continue 
                    else if math.abs(current_distance) < math.abs(current_distance) 
                        closest_distance := current_distance
                        result := current_level 
    result


KeyLevelLibrary_getNearestKeyLevelShort(KeyLevelLibraryArgs args, bool ignore_levels_currently_touching) =>
    KeyLevel result = na
    float closest_distance = na
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_level = args.key_levels.get(i)
            float current_distance = KeyLevelLibrary_getDistanceToKeyLevel(current_level)
            if current_distance <= 0
                if na(closest_distance)
                    closest_distance := current_distance 
                    result := current_level
                else
                    if ignore_levels_currently_touching and (current_distance == 0)
                        continue 
                    else if math.abs(current_distance) < math.abs(current_distance) 
                        closest_distance := current_distance
                        result := current_level 
    result




// === Libraries/EntryStrategyLibrary.pine ===
//@version=6
type ConditionDictionary
	array<string> keys = na 
	array<bool> values = na 
create_ConditionDictionary() =>
	ConditionDictionary dict = ConditionDictionary.new() 
	dict.keys := array.new<string>()
	dict.values := array.new<bool>()
	dict 
//returns true if we added a new entry
ConditionDictionary_set_value(ConditionDictionary dict, string key, bool value) =>
    int index = array.indexof(dict.keys, key)
    if index != -1
        array.set(dict.values, index, value)
		false 
    else
        dict.keys.push(key)
        dict.values.push(value)
		true
ConditionDictionary_get_value(ConditionDictionary dict, string key) => 
    int index = array.indexof(dict.keys, key)
    if index != -1
        dict.values.get(index)


enum ENTRY_ACTION_TYPE 
	EntryIsCandle //the entry is at one end of the candle with the stoploss at the other end
type EntryAction 
	string name = na 
	ENTRY_ACTION_TYPE entry_type = na 
	Direction trade_direction = na 
	OrderType order_type = na 

enum EXIT_ACTION_TYPE
	SetRiskRewardRatio
	SetTargetPrice
type ExitAction 
	string name = na 
	EXIT_ACTION_TYPE exit_type = na 
	float rr_or_target_value = na 
	TradeExitInfo trade_exit_info = na 


type EntryRule
	string rule_name = na 
	array<BooleanExpression> conditions = na 
	EntryAction entry_action = na 
	ExitAction exit_action = na

	
type EntryLibraryOutput
	bool has_output = false 
	array<EntryRule> taken_actions = na
create_EntryLibraryOutput() =>
	EntryLibraryOutput output = EntryLibraryOutput.new() 
	output.taken_actions := array.new<EntryRule>()
	output
reset_EntryLibraryOutput(EntryLibraryOutput output) =>
	output.has_output := false 
	output.taken_actions.clear()

	
type EntryLibraryArgs
	ConditionDictionary condition_dict = na 
	array<EntryRule> entry_rules = na 
	array<BooleanExpression> compound_conditions = na 
	array<EntryAction> entry_actions = na 
	array<ExitAction> exit_actions = na
	EntryLibraryOutput output = na
	TradeLibraryArgs trade_library_args = na
	KeyLevelLibraryArgs key_level_library_args = na
	MultiTimeFrameLibraryArgs multi_timeframe_library_args = na 
	bool process_longs = true 
	bool process_shorts = true 
create_EntryLibraryArgs() => 
	EntryLibraryArgs args = EntryLibraryArgs.new() 
	args.condition_dict := create_ConditionDictionary()
	args.entry_rules := array.new<EntryRule>()
	args.compound_conditions := array.new<BooleanExpression>()
	args.entry_actions := array.new<EntryAction>()
	args.exit_actions := array.new<ExitAction>()
	args.output := create_EntryLibraryOutput()
	args.trade_library_args := create_TradeLibraryArgs()
	args.key_level_library_args := create_KeyLevelLibraryArgs()
	args.multi_timeframe_library_args := create_MultiTimeFrameLibraryArgs()
	args


///////////////////////////////////
//////// FUNCTIONS FOR CONDITIONS 
//////////////////////////////////


get_condition_by_name(EntryLibraryArgs args, string name) => 
	bool found_condition = false 
	BooleanExpression condition = na 
	if args.compound_conditions.size() > 0
		for i = args.compound_conditions.size() - 1 to 0 
			BooleanExpression current_cond = args.compound_conditions.get(i)
			if current_cond.name == name 
				found_condition := true 
				condition := current_cond
	
	condition

create_and_add_compound_condition_helper(EntryLibraryArgs args, string name, bool is_simple_condition, string left_condition_name, string right_condition_name, BOOLEAN_OPERATOR op) => 
	BooleanExpression cond = na
	if is_simple_condition
		cond := create_BooleanExpression(name = name, is_base_level = is_simple_condition, base_level_val = false, left_val = na, right_val = na, operator = na)
	else
		BooleanExpression left_condition = get_condition_by_name(args, left_condition_name)
		BooleanExpression right_condition = get_condition_by_name(args, right_condition_name)
		cond := create_BooleanExpression(name = name, is_base_level = is_simple_condition, base_level_val = false, operator = op, left_val = left_condition, right_val = right_condition)
	args.compound_conditions.push(cond)
	cond //return the condition so we can use with var statement to call once per script 

create_and_add_compound_condition(EntryLibraryArgs args, string name, string left_condition_name, string right_condition_name, BOOLEAN_OPERATOR op) =>
	create_and_add_compound_condition_helper(args, name, false, left_condition_name, right_condition_name, op)

update_simple_condition(EntryLibraryArgs args, string condition_name, bool current_value) => 
	bool new_entry = ConditionDictionary_set_value(args.condition_dict, condition_name, current_value)
	if new_entry
		create_and_add_compound_condition_helper(args, condition_name, true, na, na, na) // adds simple condition

	//update the value of the compound condition
	BooleanExpression expr = get_condition_by_name(args, condition_name)
	expr.base_level_expression := current_value 


evaluate_conditions(EntryLibraryArgs args) =>
	array<BooleanExpression> conditions = args.compound_conditions
	if conditions.size() > 0
		for i = conditions.size() - 1 to 0 
			BooleanExpression current_condition = conditions.get(i)
			evaluate_BooleanExpression(current_condition)


stringify_conditions(EntryLibraryArgs args) => 
	string my_string = "Conditions:\n"
	array<BooleanExpression> conditions = args.compound_conditions
	if conditions.size() > 0
		for i = conditions.size() - 1 to 0 
			BooleanExpression current_condition = conditions.get(i)
			my_string += current_condition.name + " = " +str.tostring(current_condition.evaluated_value) + "\n"



	

///////////////////////////////////
//////// FUNCTIONS FOR ACTIONS
//////////////////////////////////

create_EntryAction(string name, ENTRY_ACTION_TYPE action_type, Direction trade_direction, OrderType order_type) => 
	EntryAction action = EntryAction.new(name, action_type, trade_direction, order_type)
	action 
// not to be used with the same action on every candle 
add_EntryAction(EntryLibraryArgs args, EntryAction action) =>
	args.entry_actions.push(action)
create_and_add_EntryAction(EntryLibraryArgs args, string name, ENTRY_ACTION_TYPE action_type, Direction trade_direction, OrderType order_type) =>
	EntryAction action = create_EntryAction(name, action_type, trade_direction, order_type)
	add_EntryAction(args, action)
	action // return action object so function can be used with var to be called once per script 

get_entry_action_by_name(EntryLibraryArgs args, string name) => 
	EntryAction Action = na 
	if args.entry_actions.size() > 0
		for i = args.entry_actions.size() - 1 to 0 
			EntryAction cur_entry = args.entry_actions.get(i)
			if cur_entry.name == name 
				Action := cur_entry
	Action


create_and_add_ExitAction(EntryLibraryArgs args, string name, EXIT_ACTION_TYPE action_type, float exit_value) =>
	ExitAction action = ExitAction.new(name, action_type, exit_value)
	action.trade_exit_info := TradeExitInfo.new()
	args.exit_actions.push(action)
	action

get_exit_action_by_name(EntryLibraryArgs args, string name) => 
	ExitAction Action = na 
	if args.exit_actions.size() > 0
		for i = args.exit_actions.size() - 1 to 0 
			ExitAction cur_exit = args.exit_actions.get(i)
			if cur_exit.name == name 
				Action := cur_exit
	Action

update_exit_action_value(EntryLibraryArgs args, string name, float value) =>
	int return_value = 0
	ExitAction exit_action = get_exit_action_by_name(args, name)
	if not na(exit_action)
		exit_action.rr_or_target_value := value 
	else
		return_value := -1 
	return_value

//returns 0 on success error code otherwise. Updates the exit action, which should apply to every rule with that action
EntryStrategyLibrary_updateExitActionBreakeven(EntryLibraryArgs args, string exit_action_name, bool will_break_even = true, int breakeven_on_n = 1)=>
	int return_value = 0
	ExitAction exit_action = get_exit_action_by_name(args, exit_action_name)
	if not na(exit_action)
		exit_action.trade_exit_info.will_break_even := will_break_even
		exit_action.trade_exit_info.breakeven_on_n := breakeven_on_n
	else
		return_value := -1 
	return_value	


// needs to be called on the same candle that the entry is for
create_trade_from_EntryAction_and_ExitAction(EntryLibraryArgs args, EntryAction entry_action, ExitAction exit_action, int candle_index) =>
	Entry entry = na 
	bool is_long = entry_action.trade_direction == Direction.Long 
	bool is_short = entry_action.trade_direction == Direction.Short
	float entry_price = 0
	float stop_loss_price = 0
	float target_price = 0
	//handle entry action 
	if entry_action.entry_type == ENTRY_ACTION_TYPE.EntryIsCandle
		if is_long 
			entry_price := high 
			stop_loss_price := low 
		else if is_short 
			entry_price := low 
			stop_loss_price := high 

	//process exit action 
	if exit_action.exit_type == EXIT_ACTION_TYPE.SetRiskRewardRatio
		float rr = exit_action.rr_or_target_value
		entry := create_Entry_with_target_RR(entry_action.trade_direction, entry_action.order_type, entry_price, stop_loss_price, rr, candle_index)
	else if exit_action.exit_type == EXIT_ACTION_TYPE.SetTargetPrice
		float target = exit_action.rr_or_target_value
		entry := create_Entry_with_target_price(entry_action.trade_direction, entry_action.order_type, entry_price, stop_loss_price, target, candle_index)

	if exit_action.trade_exit_info.will_break_even
		TradeManagerLibrary_setEntryBreakeven(args.trade_library_args, entry,exit_action.trade_exit_info.breakeven_on_n)
	entry

take_active_trades(EntryLibraryArgs args) =>
	array<EntryRule> active_actions = args.output.taken_actions
	if active_actions.size() > 0 
		for i = active_actions.size() - 1 to 0 
			EntryAction current_entry_action = active_actions.get(i).entry_action
			ExitAction current_exit_action = active_actions.get(i).exit_action
			Entry entry = create_trade_from_EntryAction_and_ExitAction(args, current_entry_action, current_exit_action, bar_index)
			place_trade(args.trade_library_args, entry)


	
///////////////////////////////////
//////// FUNCTIONS FOR RULES
//////////////////////////////////

create_and_add_EntryRule(EntryLibraryArgs args, string name, string condition_name, string entry_action_name, string exit_action_name) => 
	//look for the condition by its name 
	BooleanExpression cond = get_condition_by_name(args, condition_name)
	EntryAction entry_action = get_entry_action_by_name(args, entry_action_name)
	ExitAction exit_action = get_exit_action_by_name(args, exit_action_name)
	array<BooleanExpression> conditions = array.new<BooleanExpression>()
	conditions.push(cond)
	EntryRule rule = EntryRule.new(name, conditions, entry_action, exit_action)
	args.entry_rules.push(rule)
	rule 
	 

get_rule_by_name(EntryLibraryArgs args, string name) =>  
	EntryRule rule = na 
	array<EntryRule> entry_rules = args.entry_rules
	if entry_rules.size() > 0 
		for i = entry_rules.size() - 1 to 0 
			EntryRule current_rule = entry_rules.get(i)
			if current_rule.rule_name == name 
				rule := current_rule 
	rule
	

add_condition_to_EntryRule(EntryLibraryArgs args, string rule_name, string condition_name) => 
	EntryRule rule = get_rule_by_name(args, rule_name)
	BooleanExpression cond = get_condition_by_name(args, condition_name)

	//add condition if it does not already exist
	bool already_exists = false 
	if rule.conditions.size() > 0 
		for i = rule.conditions.size() - 1 to 0
			if rule.conditions.get(i).name == condition_name 
				already_exists := true 
	
	if not already_exists
		rule.conditions.push(cond)



process_EntryRules(EntryLibraryArgs args) => 
	array<EntryRule> entry_rules = args.entry_rules 
	if entry_rules.size() > 0
		for i = entry_rules.size() - 1 to 0 
			EntryRule current_rule = entry_rules.get(i)
			//make sure all conditions are valid 
			bool all_conditions_met = true
			for j = current_rule.conditions.size() - 1 to 0
				if current_rule.conditions.get(j).evaluated_value != true 
					all_conditions_met := false 
			
			if all_conditions_met
				//process if we are allowed to take longs and/or shorts 
				bool is_long = current_rule.entry_action.trade_direction == Direction.Long
				bool is_short = current_rule.entry_action.trade_direction == Direction.Short
				if (is_long and args.process_longs) or (is_short and args.process_shorts)
					args.output.taken_actions.push(current_rule)
					args.output.has_output := true
				
				
has_output(EntryLibraryArgs args) =>
	args.output.has_output
get_output(EntryLibraryArgs args) =>
	args.output.taken_actions

EntryStrategyLibrary_process_candle(EntryLibraryArgs args) => 
	// clear the output 
	reset_EntryLibraryOutput(args.output)
	//first evaluate / update conditions
	evaluate_conditions(args)
	// then check rules for conditions that have been met 
	process_EntryRules(args)
	//then take each active trade action and create a trade from it 
	take_active_trades(args)
	//process the trades with the trade library 
	TradeManagerLibrary_process_candle(args.trade_library_args)
	



// === Strategies/FinalStrategy.pine ===
//@version=6
strategy("FinalStrat", calc_on_every_tick = true)
//place a trade based on an entry 
FinalStrategy_process_entry(Entry entry) =>
    bool should_place_trade = (entry.state == EntryState.Placed) and (entry.index == bar_index)
    if should_place_trade
        string trade_id = str.tostring(entry.index)
        entry.additional_data.trade_id := trade_id
        bool is_long = entry.dir == Direction.Long
        bool is_short = entry.dir == Direction.Short
        bool is_entry_limit = entry.orderType == OrderType.Limit
        bool is_entry_stop = entry.orderType == OrderType.Stop
        if is_entry_limit
            strategy.entry(id = trade_id, direction = is_long ? strategy.long : strategy.short, limit = entry.entryPrice, qty = entry.num_shares)
        if is_entry_stop
            strategy.entry(id = trade_id, direction = is_long ? strategy.long : strategy.short, stop = entry.entryPrice, qty = entry.num_shares)
        string exit_id = "exit_" + trade_id
        strategy.exit(id = exit_id, from_entry = trade_id, stop = entry.stopLossPrice, limit = entry.targetPrice)

    bool should_cancel_trade = (entry.state == EntryState.Invalidated)
    if should_cancel_trade
        strategy.cancel(id = entry.additional_data.trade_id)


//////////////////////////////////////// TESTING ///////////////////////////////////////////
type customStrategyArgs 
    int num_timeframes = 0 
    array<int> timeframes = na 
    multi_timeframe_library_args = na 
    array<InsideCandleArgs> timeframe_inside_candle_args = na
create_customStrategyArgs() => 
    customStrategyArgs args = customStrategyArgs.new() 
    args.timeframes := array.new<int>() 
    args.multi_timeframe_library_args := create_MultiTimeFrameLibraryArgs() 
    args.timeframe_inside_candle_args := array.new<InsideCandleArgs>() 
    args

customStrategy_addTimeframe(customStrategyArgs args, int timeframe, bool tracks_inside_candle = false) => 
    MultiTimeFrameLibrary_keepTrackofTimeFrame(args.multi_timeframe_library_args, timeframe)

    //inside candle tracker 
    InsideCandleArgs inside_candle_args = na 
    if tracks_inside_candle
        inside_candle_args := create_InsideCandleArgs()
    args.timeframe_inside_candle_args.push(inside_candle_args)



helper_customStrategy_update(customStrategyArgs args, int timeframe_index, TimeFrameCandle current_candle) =>
    //update inside candle lib
    InsideCandleArgs inside_candle_args = args.timeframe_inside_candle_args.get(timeframe_index)
    if not na(inside_candle_args)
        InsideCandleLibrary_processCandle(inside_candle_args, current_candle)


customStrategy_update(customStrategyArgs args) => 
    MultiTimeFrameLibrary_update(args.multi_timeframe_library_args)
    //check if we have any new HTF candles 
    MultiTimeFrameLibraryOutput timeframe_lib_output = args.multi_timeframe_library_args.output
    if timeframe_lib_output.something_has_changed
        if timeframe_lib_output.timeframe_candle_has_changed.size() > 0 
            for i = timeframe_lib_output.timeframe_candle_has_changed.size() - 1 to 0 
                bool candle_has_changed = timeframe_lib_output.timeframe_candle_has_changed.get(i)
                if candle_has_changed
                    TimeFrameCandle current_candle = timeframe_lib_output.current_candles.get(i)
                    MultiTimeFrameLibraryDebugger_drawCandle(args.multi_timeframe_library_args, current_candle)

        

var customStrategyArgs custom_strategy_args = create_customStrategyArgs()
var bool is_initialized = false 
if not is_initialized 
    customStrategy_addTimeFrame(custom_strategy_args, 5, tracks_inside_candle = true)
customStrategy_update()


var EntryLibraryArgs args = create_EntryLibraryArgs()
args.trade_library_args.debugger.print_active_trades_when_something_changes := false 
// want to code in Longs for Green Down Candles, and Shorts for Red Up Candles 

// simple conditions,  red up candle and green down candle 
var string red_candle_condition_name = "is_red_candle"
var string green_candle_condition_name = "is_green_candle"
var string up_candle_condition_name = "is_up_candle"
var string down_candle_condition_name = "is_down_candle"
is_current_candle_red() =>
	close < open
is_current_candle_green() => 
	close > open 
is_candle_up() => 
	(high > high[1]) and (low > low[1])
is_candle_down() => 
	(high < high[1]) and (low < low[1])
update_simple_condition(args,red_candle_condition_name,is_current_candle_red())
update_simple_condition(args,green_candle_condition_name, is_current_candle_green())
update_simple_condition(args, up_candle_condition_name, is_candle_up())
update_simple_condition(args, down_candle_condition_name, is_candle_down())

var string past_start_time_condition_name = "is_past_start_time"
is_after_datetime(int year_in, int month_in, int day_in, int hour_in, int minute_in) =>
    int target_timestamp = timestamp("UTC", year_in, month_in, day_in, hour_in, minute_in)
    bool is_past = time >= target_timestamp
    is_past
update_simple_condition(args,past_start_time_condition_name, is_after_datetime(2025,6,4,0,0))

// compound conditions 
var string red_up_candle_condition_name = "is_red_up_candle"
var string green_down_candle_condition_name = "is_green_down_candle"
var red_up_condition = create_and_add_compound_condition(args, red_up_candle_condition_name, red_candle_condition_name, up_candle_condition_name, BOOLEAN_OPERATOR.AND)
var green_down_condition = create_and_add_compound_condition(args, green_down_candle_condition_name, green_candle_condition_name, down_candle_condition_name, BOOLEAN_OPERATOR.AND)


// entry actions 
var entry_action_long_stop_name = "Place Long Stop On Current Candle"
var entry_action_short_stop_name = "Place Short Stop On Current Candle"
var EntryAction entry_action_long_stop = create_and_add_EntryAction(args, entry_action_long_stop_name, ENTRY_ACTION_TYPE.EntryIsCandle,Direction.Long, OrderType.Stop)
var EntryAction entry_action_short_stop = create_and_add_EntryAction(args, entry_action_short_stop_name, ENTRY_ACTION_TYPE.EntryIsCandle,Direction.Short, OrderType.Stop)

//key levels 
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma20", ta.sma(close, 20))
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma50", ta.sma(close, 50))
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma100", ta.sma(close, 100))
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma200", ta.sma(close, 200))

var string touching_sma_condition_name = "TouchingSMA_20_50_100_200"
update_simple_condition(args,touching_sma_condition_name, KeyLevelLibrary_isPriceTouchingAnyKeyLevel(args.key_level_library_args))



// Rules Taking Entries touching Key Levels For 1R
var exit_action_1R_name = "Exit at 1R"
var ExitAction exit_action_1R = create_and_add_ExitAction(args, exit_action_1R_name, EXIT_ACTION_TYPE.SetRiskRewardRatio, 1)
var rc = EntryStrategyLibrary_updateExitActionBreakeven(args, exit_action_1R_name, will_break_even = true, breakeven_on_n = 1)

var string red_up_1r_rule_name = "Red_Up_Candle_Touching_Key_Level_1R_Rule"
var string green_down_1r_rule_name = "Green_Down_Candle_Touching_Key_Level_1R_Rule"
var EntryRule red_up_1r_rule = create_and_add_EntryRule(args, red_up_1r_rule_name, red_up_candle_condition_name, entry_action_short_stop_name, exit_action_1R_name)
var EntryRule green_down_1r_rule = create_and_add_EntryRule(args, green_down_1r_rule_name, green_down_candle_condition_name, entry_action_long_stop_name, exit_action_1R_name)

add_condition_to_EntryRule(args, red_up_1r_rule_name, past_start_time_condition_name)
add_condition_to_EntryRule(args, green_down_1r_rule_name, past_start_time_condition_name)
//add_condition_to_EntryRule(args, red_up_1r_rule_name, touching_sma_condition_name)
//add_condition_to_EntryRule(args, green_down_1r_rule_name, touching_sma_condition_name)


// Rules Taking Entries making 1R or less touching nearest key level 
// var exit_action_nearest_key_level_long_name = "Exit at nearest key level LONG"
// var ExitAction exit_action_nearest_key_level_long = create_and_add_ExitAction(args, exit_action_nearest_key_level_long_name, EXIT_ACTION_TYPE.SetTargetPrice, 0) //need to update this every bar
// var exit_action_nearest_key_level_short_name = "Exit at nearest key level SHORT"
// var ExitAction exit_action_nearest_key_level_short = create_and_add_ExitAction(args, exit_action_nearest_key_level_short_name, EXIT_ACTION_TYPE.SetTargetPrice, 0) //need to update this every bar

// var string red_up_nearest_level_rule_name = "Red_Up_Candle_Near_Key_Level_Rule"
// var string green_down_nearest_level_rule_name = "Green_Down_Candle_Near_Key_Level_Rule"
// var EntryRule red_up_nearest_level_rule = create_and_add_EntryRule(args, red_up_nearest_level_rule_name, red_up_candle_condition_name, entry_action_short_stop_name, exit_action_nearest_key_level_short_name)
// var EntryRule green_down_nearest_level_rule = create_and_add_EntryRule(args, green_down_nearest_level_rule_name, green_down_candle_condition_name, entry_action_long_stop_name, exit_action_nearest_key_level_long_name)


// var string near_sma_condition_long_name = "NearSMA_20_50_100_200 LONG"
// KeyLevel nearest_key_level_long = KeyLevelLibrary_getNearestKeyLevelLong(args.key_level_library_args, true)
// bool is_near_sma_long_helper = false 
// if not na(nearest_key_level_long)
//     is_near_sma_long_helper := MiscLibrary_isMakingAtMost_R_toPrice(high, low, nearest_key_level_long.current_value, 1)
//     update_exit_action_value(args, exit_action_nearest_key_level_long_name, nearest_key_level_long.current_value)
// update_simple_condition(args, near_sma_condition_long_name, is_near_sma_long_helper)


// var string near_sma_condition_short_name = "NearSMA_20_50_100_200 SHORT"
// KeyLevel nearest_key_level_short = KeyLevelLibrary_getNearestKeyLevelShort(args.key_level_library_args, true)
// bool is_near_sma_short_helper = false 
// if not na(nearest_key_level_short)
//     is_near_sma_short_helper := MiscLibrary_isMakingAtMost_R_toPrice(low, high, nearest_key_level_short.current_value, 1)
//     update_exit_action_value(args, exit_action_nearest_key_level_short_name, nearest_key_level_short.current_value)
// update_simple_condition(args, near_sma_condition_short_name, is_near_sma_long_helper)


// add_condition_to_EntryRule(args, red_up_nearest_level_rule_name, past_start_time_condition_name)
// add_condition_to_EntryRule(args, green_down_nearest_level_rule_name, past_start_time_condition_name)
// add_condition_to_EntryRule(args, red_up_nearest_level_rule_name, near_sma_condition_short_name)
// add_condition_to_EntryRule(args, green_down_nearest_level_rule_name, near_sma_condition_long_name)



args.process_longs := false 
args.process_shorts := false 
args.trade_library_args.parameters.pyramiding_allowed := true
EntryStrategyLibrary_process_candle(args)

array<Entry> entries = args.trade_library_args.entry_array
if entries.size() > 0 
    for i = entries.size() - 1 to 0 
        FinalStrategy_process_entry(entries.get(i))







