// === Libraries/MiscLibrary.pine ===
MiscLibrary_isMakingAtLeast_R_toPrice(float entry_price, float stop_loss_price, float target_price, float target_R) =>
    distance_to_stop = entry_price - stop_loss_price
    distance_to_target = target_price - entry_price
    float rr = distance_to_target / distance_to_stop
    rr >= target_R 

MiscLibrary_isMakingAtMost_R_toPrice(float entry_price, float stop_loss_price, float target_price, float target_R) =>
    distance_to_stop = entry_price - stop_loss_price
    distance_to_target = target_price - entry_price
    float rr = distance_to_target / distance_to_stop
    rr <= target_R 


// === Libraries/ChartDrawingLibrary.pine ===
/////////////// Chart Drawing Library //////////////////////////////////////////////////////////
//Supports grouping different sets of boxes / drawings into named groups
//Each group has one active (dynamic) drawing that updates every candle, and a set of finished (static) drawings that are drawn once. 
//Start_new_box(group_name, coordinates)
//Update_box(group_name, coordinates)
//Finish_box(group_name, coordinates)

type ChartDrawingBox
	float top_price = na 
	float bottom_price = na 
	int left_bar_index = na 
	int right_bar_index = na
	color box_color = na 
	color border_color = na
	box tv_box_item = na

type ChartDrawingLabel
	int bar_index_x = na 
	float price_y = na 
	color label_color = na
	string label_text = na
	label tv_label_item = na 
	

type ChartDrawingItem
	string name = na
	ChartDrawingBox chart_box = na
	ChartDrawingLabel chart_label = na


type ChartDrawingGroup
	string name = na
	array<ChartDrawingItem> current_drawings = na
	array<ChartDrawingItem> finished_drawings = na 

	int max_boxes_in_group = 50 //no more than 50 boxes drawn from this group
	int max_box_width = 200  //if we try to draw a box thats that big


type ChartDrawingArgs
	array<ChartDrawingGroup> groups = na
ChartDrawingLibrary_createChartDrawingArgs() =>
	ChartDrawingArgs args = ChartDrawingArgs.new() 
	args.groups := array.new<ChartDrawingGroup>()
	args

helper_getChartDrawingGroupByName(ChartDrawingArgs args, string group_name) =>
	ChartDrawingGroup result = na 
	if args.groups.size() > 0
		for i = args.groups.size() - 1 to 0
			ChartDrawingGroup current_group = args.groups.get(i)
			if group_name == current_group.name
				result := current_group 
				break
	result 

helper_getCurrentChartDrawingItemByName(ChartDrawingArgs args, ChartDrawingGroup group, string item_name) =>
	ChartDrawingItem result = na 
	if group.current_drawings.size() > 0 
		for i = group.current_drawings.size() - 1 to 0 
			ChartDrawingItem current_item = group.current_drawings.get(i)
			if current_item.name == item_name 
				result := current_item 
				break 
	result 
 
helper_createAndAdd_ChartDrawingGroup(ChartDrawingArgs args, string group_name) =>
	ChartDrawingGroup group = ChartDrawingGroup.new()
	group.name := group_name 
	group.finished_drawings := array.new<ChartDrawingItem>() 
	group.current_drawings := array.new<ChartDrawingItem>()
	args.groups.push(group)
	group 

helper_createAndAdd_ChartDrawingItem(ChartDrawingArgs args, ChartDrawingGroup group, string item_name) =>
	ChartDrawingItem item = ChartDrawingItem.new() 
	item.name := item_name 
	group.current_drawings.push(item)
	item 
	
helper_removeCurrentChartDrawingItemByName(ChartDrawingArgs args, ChartDrawingGroup group, string item_name) =>
	if group.current_drawings.size() > 0
		for i = group.current_drawings.size() - 1 to 0 
			if group.current_drawings.get(i).name == item_name 
				group.current_drawings.remove(i)
				break //assumes no duplicates

helper_undrawChartDrawingItem(ChartDrawingArgs args, ChartDrawingItem item) =>
	//check for chart box 
	if not na(item.chart_box)
		if not na(item.chart_box.tv_box_item)
			item.chart_box.tv_box_item.delete()
			item.chart_box.tv_box_item := na 
	//check for labels 
	if not na(item.chart_label)
		if not na(item.chart_label.tv_label_item)
			item.chart_label.tv_label_item.delete()
			item.chart_label.tv_label_item := na 

helper_drawChartDrawingItem(ChartDrawingArgs args, ChartDrawingItem item) =>
	//chart box 
	if not na(item.chart_box)
		ChartDrawingBox chart_box = item.chart_box
		if na(chart_box.tv_box_item)
			chart_box.tv_box_item := box.new(left = chart_box.left_bar_index,right = chart_box.right_bar_index,
         		top = chart_box.top_price, bottom = chart_box.bottom_price, bgcolor = chart_box.box_color, border_color = chart_box.border_color)

	if not na(item.chart_label)
		ChartDrawingLabel chart_label = item.chart_label
		if na(chart_label.tv_label_item)
			chart_label.tv_label_item := label.new(x = chart_label.bar_index_x, y = chart_label.price_y, text = chart_label.label_text)	


ChartDrawingLibrary_UpdateDrawing(ChartDrawingArgs args, string group_name, string item_name, ChartDrawingBox chart_box = na, ChartDrawingLabel chart_label = na) => 
	ChartDrawingGroup group = helper_getChartDrawingGroupByName(args, group_name)
	// add the group if it doesn't already exist
	if na(group)
		group := helper_createAndAdd_ChartDrawingGroup(args, group_name)

	//add the item if it doesn't already exist
	ChartDrawingItem item = helper_getCurrentChartDrawingItemByName(args, group, item_name)
	if na(item)
		item := helper_createAndAdd_ChartDrawingItem(args, group, item_name)
		
	//undraw the previous drawing before we draw the new one 
	helper_undrawChartDrawingItem(args, item)

	//update the new parts of the drawing 
	item.chart_box := chart_box 
	item.chart_label := chart_label

	//draw the new box
	helper_drawChartDrawingItem(args, item)

	
helper_ChartDrawingLibrary_addFinishedDrawing(ChartDrawingArgs args, ChartDrawingItem item, ChartDrawingGroup group) =>
	group.finished_drawings.push(item)
	//check if above max 
	if group.finished_drawings.size() > group.max_boxes_in_group
		group.finished_drawings.remove(0)//remove first item

//returns 0 on success, 1 on error
ChartDrawingLibrary_FinishDrawing(ChartDrawingArgs args, string group_name, string item_name) => 
	int return_code = 0
	ChartDrawingGroup group = helper_getChartDrawingGroupByName(args, group_name)
	ChartDrawingItem item = na
	// find if item exists 
	if not na(group)
		item := helper_getCurrentChartDrawingItemByName(args, group, item_name)
	if not na(item)
		//assumes the box is already drawn 
		helper_removeCurrentChartDrawingItemByName(args, group, item.name)
		helper_ChartDrawingLibrary_addFinishedDrawing(args = args, item = item, group = group)
		return_code := 0
	else
		//we should not reach here this is an error
		return_code := 1
	return_code 



ChartDrawingLibrary_CancelDrawing(ChartDrawingArgs args, string group_name, string item_name) => 
	int return_code = 0
	ChartDrawingGroup group = helper_getChartDrawingGroupByName(args, group_name)
	ChartDrawingItem item = na
	// find if item exists 
	if not na(group)
		item := helper_getCurrentChartDrawingItemByName(args, group, item_name)
	if not na(item)
		//delete the drawing 
		item.chart_box.tv_box_item.delete()
		helper_removeCurrentChartDrawingItemByName(args, group, item.name)
		return_code := 0
	else
		//we should not reach here this is an error
		return_code := 1
	return_code 


ChartDrawingLibrary_createChartDrawingBox(ChartDrawingArgs args, float top_price, float bottom_price, int left_bar_index, int right_bar_index, color bg_color, color border_color) =>
	ChartDrawingBox my_box = ChartDrawingBox.new()
	my_box.top_price := top_price 
	my_box.bottom_price := bottom_price 
	my_box.left_bar_index := left_bar_index 
	my_box.right_bar_index := right_bar_index
	my_box.box_color := bg_color 
	my_box.border_color := border_color

	my_box //return the box 

ChartDrawingLibrary_createChartDrawingLabel(ChartDrawingArgs args, string label_text, int bar_index_x, float price_y, color label_color = na) =>
	ChartDrawingLabel my_label = ChartDrawingLabel.new()
	my_label.bar_index_x := bar_index_x 
	my_label.price_y := price_y 
	my_label.label_color := label_color 
	my_label.label_text := label_text 
	my_label 



	

// === Libraries/TradeManagerLibrary.pine ===
//@version=6
// === ENUM DEFINITIONS ===

// Direction of the trade
enum Direction
    Long    // Buy-side setup
    Short   // Sell-side setup
stringify_Direction(Direction dir) =>
    string result = ""
    if dir == Direction.Long
        result := "Long"
    else if dir == Direction.Short
        result := "Short"
    result


// Order type (reserved for future use; not used in core logic)
enum OrderType
    Limit
    Stop
stringify_OrderType(OrderType t) =>
    string result = ""
    if t == OrderType.Limit
        result := "Limit"
    else if t == OrderType.Stop
        result := "Stop"
    result


// Current state of a trade
enum EntryState
    Placed         // Waiting to be triggered
    Entered        // Actively in a trade
    Invalidated    // Stopped before entry (e.g. stop hit first)
    Success        // Target hit
    Loss           // Stop loss hit
    Breakeven      // got stopped out at breakeven
stringify_EntryState(EntryState s) =>
    string result = ""
    if s == EntryState.Placed
        result := "Placed"
    else if s == EntryState.Entered
        result := "Entered"
    else if s == EntryState.Invalidated
        result := "Invalidated"
    else if s == EntryState.Success
        result := "Success"
    else if s == EntryState.Loss
        result := "Loss"
    else if s == EntryState.Breakeven
        result := "Breakeven"
    result


type EntryDebugData
    bool should_draw = false //draw with the debugger
    bool is_drawn_on_screen = false
    string drawing_group_name = na 
    string drawing_item_name = na
    bool drawing_finished = false
    float transparency_level = 75 // 100 = fully transparent, 0 = fully colored 
// === ENTRY STRUCTURE ===
type EntryAdditionalData
    float original_stopLossPrice = 0

    int placed_on_index = 0
    int entered_on_index = 0 
    int invalidated_on_index = 0 
    int lost_on_index = 0
    int won_on_index = 0
    int breakeven_on_index = 0

    string trade_id = na //for strategy tester 
    EntryDebugData debug_data = na
helper_createEntryAdditionalData() => 
    EntryAdditionalData additional_data = EntryAdditionalData.new()
    additional_data.debug_data := EntryDebugData.new()
    additional_data
type TradeExitInfo 
    bool will_break_even = false
    bool is_currently_break_even = false
    int breakeven_on_n = 1 //break even on the n'th candle after entry, only 1 and higher is currently supported, any other value is considered break_even disabled
// Represents a single trade
type Entry
    Direction dir              // Trade direction
    OrderType orderType        // Entry type (not currently used in logic)
    float entryPrice           // Entry level
    float stopLossPrice        // Stop loss level
    float targetPrice          // Target level
    float risk_reward_ratio
    EntryState state           // Current status of this trade
    int num_shares             // Optional: share/contract size (default = 1)
    int index                  // bar index (needed to not process the hitting of the stop loss on the actual entry candle)
    EntryAdditionalData additional_data
    TradeExitInfo trade_exit_info

stringify_Entry(Entry e) =>
    string result = "ENTRY (index = " + str.tostring(e.index) + " )\n"
    result += "\tDir: " + stringify_Direction(e.dir) + "\n"
    result += "\tType: " + stringify_OrderType(e.orderType) + "\n"
    result += "\tEntry: " + str.tostring(e.entryPrice) + "\n"
    result += "\tSL: " + str.tostring(e.stopLossPrice) + "\n"
    result += "\tTP: " + str.tostring(e.targetPrice) + "\n"
    result += "\tRR: " + str.tostring(e.risk_reward_ratio) + "\n"
    result += "\tState: " + stringify_EntryState(e.state) + "\n"
    result += "\tSize: " + str.tostring(e.num_shares)
    result



calculate_RR_ratio_based_on_prices(float entry_price, float stop_loss_price, float target_price) =>
    float distance = entry_price - stop_loss_price 
    float distance_to_target = target_price - entry_price
    float RR = distance_to_target / distance
    RR

calculate_target_based_on_RR_ratio(float entry_price, float stop_loss_price, float RR_ratio) =>
    float distance = entry_price - stop_loss_price
    float distance_to_target = distance * RR_ratio 
    float target = entry_price + distance_to_target
    target


// Creates a new Entry instance with default state
helper_createEntry(Direction dir, OrderType orderType, float entryPrice, float stopLossPrice, int index) =>
    Entry my_entry = Entry.new() 
    my_entry.dir := dir 
    my_entry.orderType := orderType 
    my_entry.entryPrice := entryPrice
    my_entry.stopLossPrice := stopLossPrice
    my_entry.state := EntryState.Placed
    my_entry.num_shares := 1 
    my_entry.index := index
    my_entry.additional_data := helper_createEntryAdditionalData()
    my_entry.additional_data.placed_on_index := bar_index 
    my_entry.trade_exit_info := TradeExitInfo.new()
    my_entry




create_Entry_with_target_price(Direction dir, OrderType orderType, float entryPrice, float stopLossPrice, float targetPrice, int index) =>
    Entry my_entry = helper_createEntry(dir = dir, orderType = orderType, entryPrice = entryPrice, stopLossPrice = stopLossPrice, index = index)
    my_entry.targetPrice := targetPrice
    //calculate RR
    my_entry.risk_reward_ratio := calculate_RR_ratio_based_on_prices(entryPrice, stopLossPrice, targetPrice)
    my_entry

create_Entry_with_target_RR(Direction dir, OrderType orderType, float entryPrice, float stopLossPrice, float targetRR, int index) =>
    Entry my_entry = helper_createEntry(dir = dir, orderType = orderType, entryPrice = entryPrice, stopLossPrice = stopLossPrice, index = index)
    my_entry.risk_reward_ratio := targetRR
    //calculate RR
    my_entry.targetPrice := calculate_target_based_on_RR_ratio(entryPrice,stopLossPrice,targetRR)
    my_entry

// === TRADE WRAPPER STRUCTURE ===

// keeps track of total profit, and possibly other metrics in the future 
type TradeDataCollector
    int num_trades_entered = 0
    int num_trades_won = 0 
    int num_trades_lost = 0
    int num_trades_breakeven = 0
    float total_profit_USD = 0 
    float total_profit_R = 0
stringify_TradeDataCollector(TradeDataCollector data) =>
    string result = ""
    result += "Trades Entered: " + str.tostring(data.num_trades_entered) + "\n"
    result += "Trades Won: " + str.tostring(data.num_trades_won) + "\n"
    result += "Trades Lost: " + str.tostring(data.num_trades_lost) + "\n"
    result += "Total Profit (USD): " + str.tostring(data.total_profit_USD) + "\n"
    result += "Total Profit (R): " + str.tostring(data.total_profit_R)
    result


type InstrumentInfo
    float tick_value_in_USD = 0
    float USD_made_per_tick = 0
create_InstrumentInfo() =>
    InstrumentInfo info = InstrumentInfo.new() 
    info.tick_value_in_USD := syminfo.mintick
    info.USD_made_per_tick := (syminfo.pointvalue * syminfo.mintick)
    info
stringify_InstrumentInfo(InstrumentInfo info) => 
    string my_string = "InstrumentInfo: "
    my_string += "\ttick_value_in_USD = " + str.tostring(info. tick_value_in_USD) + "\n"
    my_string += "\tUSD_made_per_tick = " + str.tostring(info.USD_made_per_tick)
    my_string

type TradeLibraryDebuggingInfo
    bool enable_debugging = true
    ChartDrawingArgs chart_drawing_library_args = na 
    string group_name = "TradeLibraryEntries"
    color winning_trade_color = color.green
    color losing_trade_color = color.red 
    color breakeven_trade_color = color.blue
    color border_color_in_progress = color.blue
    color border_color_finished = color.black
    bool print_active_trades_when_something_changes = true 
helper_createTradeLibraryDebuggingInfo()=>
    TradeLibraryDebuggingInfo debugger = TradeLibraryDebuggingInfo.new()
    debugger.chart_drawing_library_args := ChartDrawingLibrary_createChartDrawingArgs()
    debugger
    
    
type TradeLibraryArgsParameters
    bool pyramiding_allowed = false 
// A container to manage multiple entries (i.e. a portfolio of trades)
type TradeLibraryArgs
    TradeLibraryArgsParameters parameters = na 
    array<Entry> entry_array = na
    TradeDataCollector data_collector = na
    InstrumentInfo instrument_info = na
    bool something_has_changed = false
    TradeLibraryDebuggingInfo debugger = na

// Initializes a new TradeLibraryArgs instance with an empty trade array
create_TradeLibraryArgs() =>
    TradeLibraryArgs args = TradeLibraryArgs.new()
    args.entry_array := array.new<Entry>()
    args.data_collector := TradeDataCollector.new()
    args.instrument_info := create_InstrumentInfo()
    args.parameters := TradeLibraryArgsParameters.new()
    args.debugger := helper_createTradeLibraryDebuggingInfo()
    args

stringify_all_trades(TradeLibraryArgs args) =>
    string my_text = na
    array<Entry> entries = args.entry_array 
    if entries.size() > 0 
        my_text := ""
        for i = entries.size() - 1 to 0 
            Entry entry = entries.get(i)
            my_text += stringify_Entry(entry) + "\n"
    my_text 

is_long_already_open(TradeLibraryArgs args) =>
    bool already_open = false 
    if args.entry_array.size() > 0 
        for i = args.entry_array.size() - 1 to 0 
            Entry entry = args.entry_array.get(i)
            if (entry.state == EntryState.Entered) and (entry.dir == Direction.Long)
                already_open := true 
                break 
    already_open 


is_short_already_open(TradeLibraryArgs args) =>
    bool already_open = false 
    if args.entry_array.size() > 0 
        for i = args.entry_array.size() - 1 to 0 
            Entry entry = args.entry_array.get(i)
            if (entry.state == EntryState.Entered) and (entry.dir == Direction.Short)
                already_open := true 
                break 
    already_open 

TradeManagerLibrary_setEntryBreakeven(TradeLibraryArgs args, Entry entry, int breakeven_on_n) =>
    entry.trade_exit_info.will_break_even := true 
    entry.trade_exit_info.breakeven_on_n := breakeven_on_n
    entry.trade_exit_info.is_currently_break_even := false
// Adds a trade entry to the array
place_trade(TradeLibraryArgs args, Entry entry) =>
    bool can_place = true 
    if args.parameters.pyramiding_allowed == false
        bool is_long = entry.dir == Direction.Long 
        bool is_short = entry.dir == Direction.Short 
        bool already_exists = false 
        if is_long 
            already_exists := is_long_already_open(args)
        else if is_short 
            already_exists := is_short_already_open(args)
        if already_exists
            can_place := false 
    if can_place 
        args.entry_array.push(entry)
    


get_entry_win_amount(TradeLibraryArgs args, Entry entry) =>
    float usd_win_distance = math.abs(entry.entryPrice - entry.targetPrice)
    int usd_win_distance_ticks = math.round(usd_win_distance / args.instrument_info.tick_value_in_USD)
    float win_in_USD = (usd_win_distance_ticks * args.instrument_info.USD_made_per_tick) * entry.num_shares
    win_in_USD

get_entry_loss_amount(TradeLibraryArgs args, Entry entry) => 
    float usd_loss_distance = math.abs(entry.entryPrice - entry.stopLossPrice)
    int usd_loss_distance_ticks = math.round(usd_loss_distance / args.instrument_info.tick_value_in_USD)
    float loss_in_USD = (usd_loss_distance_ticks * args.instrument_info.USD_made_per_tick) * entry.num_shares
    loss_in_USD

// === PER-CANDLE PROCESSING ===

process_trade_entered(TradeLibraryArgs args, Entry entry) =>
    entry.state := EntryState.Entered
    entry.additional_data.entered_on_index := bar_index 
    args.data_collector.num_trades_entered += 1
    args.something_has_changed := true 

process_trade_invalidated(TradeLibraryArgs args, Entry entry) =>
    entry.state := EntryState.Invalidated
    entry.additional_data.invalidated_on_index := bar_index
    args.something_has_changed := true

helper_TradeManagerLibrary_processTradeBreakeven(TradeLibraryArgs args, Entry entry) =>
    entry.state := EntryState.Breakeven
    args.data_collector.num_trades_breakeven += 1
    entry.additional_data.breakeven_on_index := bar_index 
    args.something_has_changed := true 

//call when price hits stoploss (breakeven, or true stoploss)
helper_TradeManagerLibrary_processTradeStopLoss(TradeLibraryArgs args, Entry entry) =>
    if entry.trade_exit_info.is_currently_break_even and (entry.entryPrice == entry.stopLossPrice)
        helper_TradeManagerLibrary_processTradeBreakeven(args, entry)
    else
        entry.state := EntryState.Loss
        args.data_collector.total_profit_R -= 1
        args.data_collector.num_trades_lost += 1
        entry.additional_data.lost_on_index := bar_index
        args.something_has_changed := true 
        args.data_collector.total_profit_USD -= get_entry_loss_amount(args, entry)
    0 //dummy return value 

process_trade_win(TradeLibraryArgs args, Entry entry) =>
    entry.state := EntryState.Success
    args.data_collector.total_profit_R += entry.risk_reward_ratio
    args.data_collector.num_trades_won += 1
    entry.additional_data.won_on_index := bar_index 
    args.something_has_changed := true    
    args.data_collector.total_profit_USD += get_entry_win_amount(args, entry)


//sets the group and item names 
helper_TradeManagerLibraryDebugger_setEntryDrawingNames(TradeLibraryArgs args, Entry entry) =>
    entry.additional_data.debug_data.drawing_group_name := args.debugger.group_name
    entry.additional_data.debug_data.drawing_item_name := stringify_Entry(entry)

//this is the only function that reads or writes the entries debugging info
TradeManagerLibraryDebugger_processAndDrawEntry(TradeLibraryArgs args, Entry entry) =>
    EntryDebugData entry_debug_info = entry.additional_data.debug_data
    //finish the drawing if we just won or lost the trade
    bool should_finish_drawing = (entry.state == EntryState.Success) or (entry.state == EntryState.Loss) or (entry.state == EntryState.Breakeven)
    should_finish_drawing := should_finish_drawing and (not entry_debug_info.drawing_finished) 
    //cancel the drawing if the entry got invalidated
    bool should_cancel_drawing = (entry.state == EntryState.Invalidated)
    //update drawing if we are mid trade or if we just placed the trade
    bool should_update_drawing = (entry.state == EntryState.Entered) or ((entry.state == EntryState.Placed) and not entry_debug_info.is_drawn_on_screen)
    //set the debugging drawing group and item names 
    if na(entry.additional_data.debug_data.drawing_item_name)
        helper_TradeManagerLibraryDebugger_setEntryDrawingNames(args, entry)
    string drawing_group_name = entry.additional_data.debug_data.drawing_group_name
    string drawing_item_name = entry.additional_data.debug_data.drawing_item_name
    ChartDrawingArgs chart_drawing_library_args = args.debugger.chart_drawing_library_args
    // cancel drawing
    if should_cancel_drawing
        ChartDrawingLibrary_CancelDrawing(chart_drawing_library_args, drawing_group_name, drawing_item_name)
    // update drawing (update one last time if finished)
    if should_update_drawing or should_finish_drawing
        //determine the box boundaries and colors 
        bool is_winning = false 
        bool is_trade_open = false 
        bool is_breakeven = false 
        bool is_long = entry.dir == Direction.Long 
        bool is_short = entry.dir == Direction.Short
        float current_price = close
        int left_bar_index = entry.index 
        int right_bar_index = 0 
        float top_price = math.max(entry.targetPrice, entry.stopLossPrice)
        float bottom_price = math.min(entry.targetPrice, entry.stopLossPrice)
        color box_color_base = na
        if entry.state == EntryState.Success
            is_winning := true 
            is_trade_open := false 
            right_bar_index := entry.additional_data.won_on_index
        else if entry.state == EntryState.Loss 
            is_winning := false 
            is_trade_open := false 
            right_bar_index := entry.additional_data.lost_on_index
        else if entry.state == EntryState.Entered
            is_winning := (is_long and current_price > entry.entryPrice) or (is_short and current_price < entry.entryPrice)
            is_trade_open := true 
            right_bar_index := bar_index
            top_price := math.max(entry.entryPrice, current_price)
            bottom_price := math.min(entry.entryPrice, current_price)
        else if entry.state == EntryState.Placed 
            is_trade_open := true 
            right_bar_index := bar_index + 1
            top_price := math.max(entry.entryPrice, entry.stopLossPrice)
            bottom_price := math.min(entry.entryPrice, entry.stopLossPrice) 
        else if entry.state == EntryState.Breakeven 
            is_trade_open := false 
            right_bar_index := bar_index 
            top_price := math.max(entry.entryPrice, entry.stopLossPrice)
            bottom_price := math.min(entry.entryPrice, entry.stopLossPrice)
            box_color_base := args.debugger.breakeven_trade_color
        
        if na(box_color_base)
            box_color_base := is_winning ? args.debugger.winning_trade_color : args.debugger.losing_trade_color
        color box_color = color.new(box_color_base, entry_debug_info.transparency_level)
        color border_color = is_trade_open ? args.debugger.border_color_in_progress : args.debugger.border_color_finished
        //create and update the box 
        ChartDrawingBox chart_box = ChartDrawingLibrary_createChartDrawingBox(chart_drawing_library_args, top_price, bottom_price, left_bar_index, right_bar_index, box_color, border_color)
        ChartDrawingLibrary_UpdateDrawing(chart_drawing_library_args, drawing_group_name, drawing_item_name, chart_box = chart_box)
        entry_debug_info.is_drawn_on_screen := true 

    //Mark as finished if applicable
    if should_finish_drawing
        ChartDrawingLibrary_FinishDrawing(chart_drawing_library_args, drawing_group_name, drawing_item_name)
        entry_debug_info.drawing_finished := true


TradeManagerLibraryDebugger_processCandle(TradeLibraryArgs args) =>
    //draw the trades 
    if args.entry_array.size() > 0
        for i = args.entry_array.size() - 1 to 0
            Entry current_entry = args.entry_array.get(i)
            TradeManagerLibraryDebugger_processAndDrawEntry(args, current_entry)

    //print a label of all trade states if something changes  
    if args.debugger.print_active_trades_when_something_changes
        if args.something_has_changed
            string label_text = stringify_all_trades(args)
            string label_id = label_text + str.tostring(time)
            ChartDrawingLabel chart_label = ChartDrawingLibrary_createChartDrawingLabel(args = args.debugger.chart_drawing_library_args,label_text = label_text, bar_index_x = bar_index, price_y = high) 
            ChartDrawingLibrary_UpdateDrawing(args = args.debugger.chart_drawing_library_args,group_name = args.debugger.group_name, item_name = label_id, chart_label = chart_label)
            ChartDrawingLibrary_FinishDrawing(args = args.debugger.chart_drawing_library_args,group_name = args.debugger.group_name, item_name = label_id)
    
        
//assumes that entry has breakeven set to true (make sure before function is called )
helper_TradeManagerLibrary_processCandleForEntryBreakeven(TradeLibraryArgs args, Entry entry) =>
    TradeExitInfo trade_exit_info = entry.trade_exit_info 
    //assumes entry.trade_exit_info.break_even = true 
    //assumes entry.state = Placed
    if not trade_exit_info.is_currently_break_even
        int num_candles_past_entry = bar_index - entry.additional_data.entered_on_index 
        bool should_be_breakeven = trade_exit_info.breakeven_on_n >= num_candles_past_entry
        if should_be_breakeven
            trade_exit_info.is_currently_break_even := true
            entry.additional_data.original_stopLossPrice := entry.stopLossPrice
            //move stoploss to entry 
            entry.stopLossPrice := entry.entryPrice 





// Checks a single candle (high/low) against a single entry and updates its state
TradeManagerLibrary_processCandleForEntry(TradeLibraryArgs args, Entry entry, float candleHigh, float candleLow) =>
    //ignore if this is the same index
    if entry.index != bar_index

        //first set the breakeven if applicable because it can affect stoplosses 
        if entry.state == EntryState.Entered 
            if entry.trade_exit_info.will_break_even and  not entry.trade_exit_info.is_currently_break_even
                helper_TradeManagerLibrary_processCandleForEntryBreakeven(args, entry)

        isLong = entry.dir == Direction.Long
        isShort = entry.dir == Direction.Short
        //Todo add worst case assumptions for stop orders vs limit orders
        crossedEntry = candleLow <= entry.entryPrice and entry.entryPrice <= candleHigh
        crossedTarget = candleLow < entry.targetPrice and entry.targetPrice < candleHigh
        completely_passed_target = (isLong and candleLow > entry.targetPrice) or (isShort and candleHigh < entry.targetPrice)
        touchedStop = (isLong and candleLow <= entry.stopLossPrice) or (isShort and candleHigh >= entry.stopLossPrice)
        if entry.state == EntryState.Placed
            if crossedEntry
                process_trade_entered(args, entry)
            else if touchedStop
                process_trade_invalidated(args, entry)
        if entry.state == EntryState.Entered
            if touchedStop
                helper_TradeManagerLibrary_processTradeStopLoss(args, entry) //handles breakeven case
            else if crossedTarget or completely_passed_target
                process_trade_win(args, entry)




// Removes trades that are no longer active (Invalidated, Success, or Loss)
remove_all_finished_trades(TradeLibraryArgs args) =>
    if args.entry_array.size() > 0
        for i = args.entry_array.size() - 1 to 0
            Entry current_entry = args.entry_array.get(i)
            bool finished = false
            if current_entry.state == EntryState.Invalidated
                finished := true
            if current_entry.state == EntryState.Loss
                finished := true
            if current_entry.state == EntryState.Success
                finished := true
            if finished
                args.entry_array.remove(i)

// Loops over all trades and processes them using the current candle's high/low
TradeManagerLibrary_process_candle(TradeLibraryArgs args) =>
    remove_all_finished_trades(args)
    args.something_has_changed := false 
    if args.entry_array.size() > 0
        for i = args.entry_array.size() - 1 to 0
            Entry current_entry = args.entry_array.get(i)
            TradeManagerLibrary_processCandleForEntry(args, current_entry, high, low)
    //optional debugging / drawing 
    if args.debugger.enable_debugging
        TradeManagerLibraryDebugger_processCandle(args)




        


// === Libraries/BooleanExpressionLibrary.pine ===
//@version=6
// === ENUMS ===

// Represents logical Boolean operators
enum BOOLEAN_OPERATOR
    AND     // Logical AND
    OR      // Logical OR
    NOT     // Logical NOT (unary)
	IS     // default 
is_BOOLEAN_OPERATOR_binary(BOOLEAN_OPERATOR op) =>
	bool result = false 
	if op == BOOLEAN_OPERATOR.AND
		result := true
	else if op == BOOLEAN_OPERATOR.OR
		result := true
	result


// === TYPES ===

// Struct for representing a Boolean expression node (base level or composite)
// - If `is_base_level_expression` is true, the node is a leaf with a fixed boolean value
// - Otherwise, it's a composite expression with an operator and children
type BooleanExpression
    string name = na // the name of the expression / condition 
    bool is_base_level_expression = false          // True if this node is a leaf
    bool base_level_expression = false             // Value for base-level expressions
    BooleanExpression left_expression = na         // Left child (required)
    BooleanExpression right_expression = na        // Right child (optional for NOT)
    BOOLEAN_OPERATOR operator = na                 // Operator applied to children
    bool evaluated_value = false                   // Cached evaluation result



// Creates a BooleanExpression struct with all required values
create_BooleanExpression(string name, bool is_base_level, bool base_level_val, BOOLEAN_OPERATOR operator, BooleanExpression left_val, BooleanExpression right_val) =>
    BooleanExpression expr = BooleanExpression.new(name, is_base_level, base_level_val, left_val, right_val, operator, false)
    expr

// Frame used to simulate recursive evaluation using an explicit stack
// Tracks whether children have been evaluated yet
type EvaluationFrame
    BooleanExpression node = na
    bool left_result = false
    bool right_result = false
    bool evaluated_left = false
    bool evaluated_right = false

// === MAIN EVALUATION FUNCTION ===

// Evaluates a BooleanExpression tree using a manual stack (non-recursive)
// Handles nested AND/OR/NOT logic in order, from bottom-up
// Caches result in node.evaluated_value and returns final result
evaluate_BooleanExpression(BooleanExpression expression) =>
    array<EvaluationFrame> stack = array.new<EvaluationFrame>()
    EvaluationFrame root = EvaluationFrame.new(expression, false, false, false, false)
    array.push(stack, root)
    bool final_result = false

    while array.size(stack) > 0
        EvaluationFrame frame = stack.pop()

        // Case 1: Base-level expression (leaf node)
        if frame.node.is_base_level_expression
            frame.node.evaluated_value := frame.node.base_level_expression

        // Case 2: Evaluate left side first
        else if not frame.evaluated_left
            EvaluationFrame left = EvaluationFrame.new(frame.node.left_expression, false, false, false, false)
            frame.evaluated_left := true
            array.push(stack, frame)
            array.push(stack, left)

        // Case 3: Evaluate right side (for binary ops only)
        else if is_BOOLEAN_OPERATOR_binary(frame.node.operator) and not frame.evaluated_right
            EvaluationFrame right = EvaluationFrame.new(frame.node.right_expression, false, false, false, false)
            frame.evaluated_right := true
            array.push(stack, frame)
            array.push(stack, right)

        // Case 4: Both children evaluated — now compute result
        else
            bool expression_result = false
            bool left_value = false
            bool right_value = false
            if frame.evaluated_left
                left_value := frame.node.left_expression.evaluated_value
            if frame.evaluated_right
                right_value := frame.node.right_expression.evaluated_value

            if frame.node.operator == BOOLEAN_OPERATOR.NOT
                expression_result := not left_value
			else if frame.node.operator == BOOLEAN_OPERATOR.IS
				expression_result := left_value
            else if frame.node.operator == BOOLEAN_OPERATOR.AND
                expression_result := left_value and right_value
            else if frame.node.operator == BOOLEAN_OPERATOR.OR
                expression_result := left_value or right_value

            frame.node.evaluated_value := expression_result

    final_result





// === Libraries/KeyLevelLibrary.pine ===
type KeyLevel
    string name = na 
    float current_value = na 

type KeyLevelLibraryArgs 
    array<KeyLevel> key_levels = na 

create_KeyLevelLibraryArgs() => 
    KeyLevelLibraryArgs args = KeyLevelLibraryArgs.new() 
    args.key_levels := array.new<KeyLevel>() 
    args


get_KeyLeveL_from_name(KeyLevelLibraryArgs args, string name) =>
    KeyLevel result = na 
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_key_level = args.key_levels.get(i)
            if current_key_level.name == name 
                result := current_key_level 
                break 
    result 

KeyLevelLibrary_updateKeyLevel(KeyLevelLibraryArgs args, string name, float value) => 
    KeyLevel level = get_KeyLeveL_from_name(args, name)
    //if it doesn't exist, add it 
    if na(level)
        level := KeyLevel.new()
        level.name := name 
        level.current_value := value 
        args.key_levels.push(level)
    else
        level.current_value := value 
    0//dummy return value


helper_isPriceTouchingKeyLevel(KeyLevel key_level) =>
    float price = key_level.current_value 
    (low <= price) and (high >= price)

KeyLevelLibrary_isPriceTouchingAnyKeyLevel(KeyLevelLibraryArgs args) =>
    bool result = false 
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_level = args.key_levels.get(i)
            if helper_isPriceTouchingKeyLevel(current_level)
                result := true 
                break 
    result 

KeyLevelLibrary_isPriceTouchingKeyLevel(KeyLevelLibraryArgs args, string name) => 
    bool result = false 
    KeyLevel level = get_KeyLeveL_from_name(args, name)
    if not na(level)
        result := helper_isPriceTouchingKeyLevel(level)
    result


//returns 0 if touching, positive if level is above price, negative if level below price
KeyLevelLibrary_getDistanceToKeyLevel(KeyLevel level) =>
    float distance = 0
    if helper_isPriceTouchingKeyLevel(level)
        distance := 0 
    else
        bool level_is_above_price = high < level.current_value
        bool level_is_below_price = not level_is_above_price
        if level_is_above_price 
            distance := level.current_value - high //should be positive
        else if level_is_below_price 
            distance := level.current_value - low //should be negative
    distance 

//returns 0 if touching (na if invalid level name), positive if level is above price, negative if level is below price 
KeyLevelLibrary_getDistanceToKeyLevelByName(KeyLevelLibraryArgs args, string name) =>
    float result = na
    KeyLevel level = get_KeyLeveL_from_name(args, name)
    if not na(level)
        result := KeyLevelLibrary_getDistanceToKeyLevel(level)
    result 



KeyLevelLibrary_getNearestKeyLevel(KeyLevelLibraryArgs args, bool ignore_levels_currently_touching) =>
    KeyLevel result = na
    float closest_distance = na
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_level = args.key_levels.get(i)
            float current_distance = KeyLevelLibrary_getDistanceToKeyLevel(current_level)
            if na(closest_distance)
                closest_distance := current_distance 
                result := current_level
            else
                if ignore_levels_currently_touching and (current_distance == 0)
                    continue 
                else if math.abs(current_distance) < math.abs(current_distance) 
                    closest_distance := current_distance
                    result := current_level 
    result
        

KeyLevelLibrary_getNearestKeyLevelLong(KeyLevelLibraryArgs args, bool ignore_levels_currently_touching) =>
    KeyLevel result = na
    float closest_distance = na
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_level = args.key_levels.get(i)
            float current_distance = KeyLevelLibrary_getDistanceToKeyLevel(current_level)
            if current_distance >= 0
                if na(closest_distance)
                    closest_distance := current_distance 
                    result := current_level
                else
                    if ignore_levels_currently_touching and (current_distance == 0)
                        continue 
                    else if math.abs(current_distance) < math.abs(current_distance) 
                        closest_distance := current_distance
                        result := current_level 
    result


KeyLevelLibrary_getNearestKeyLevelShort(KeyLevelLibraryArgs args, bool ignore_levels_currently_touching) =>
    KeyLevel result = na
    float closest_distance = na
    if args.key_levels.size() > 0 
        for i = args.key_levels.size() - 1 to 0 
            KeyLevel current_level = args.key_levels.get(i)
            float current_distance = KeyLevelLibrary_getDistanceToKeyLevel(current_level)
            if current_distance <= 0
                if na(closest_distance)
                    closest_distance := current_distance 
                    result := current_level
                else
                    if ignore_levels_currently_touching and (current_distance == 0)
                        continue 
                    else if math.abs(current_distance) < math.abs(current_distance) 
                        closest_distance := current_distance
                        result := current_level 
    result




// === Libraries/EntryStrategyLibrary.pine ===
//@version=6
type ConditionDictionary
	array<string> keys = na 
	array<bool> values = na 
create_ConditionDictionary() =>
	ConditionDictionary dict = ConditionDictionary.new() 
	dict.keys := array.new<string>()
	dict.values := array.new<bool>()
	dict 
//returns true if we added a new entry
ConditionDictionary_set_value(ConditionDictionary dict, string key, bool value) =>
    int index = array.indexof(dict.keys, key)
    if index != -1
        array.set(dict.values, index, value)
		false 
    else
        dict.keys.push(key)
        dict.values.push(value)
		true
ConditionDictionary_get_value(ConditionDictionary dict, string key) => 
    int index = array.indexof(dict.keys, key)
    if index != -1
        dict.values.get(index)


enum ENTRY_ACTION_TYPE 
	EntryIsCandle //the entry is at one end of the candle with the stoploss at the other end
type EntryAction 
	string name = na 
	ENTRY_ACTION_TYPE entry_type = na 
	Direction trade_direction = na 
	OrderType order_type = na 

enum EXIT_ACTION_TYPE
	SetRiskRewardRatio
	SetTargetPrice
type ExitAction 
	string name = na 
	EXIT_ACTION_TYPE exit_type = na 
	float rr_or_target_value = na 
	TradeExitInfo trade_exit_info = na 


type EntryRule
	string rule_name = na 
	array<BooleanExpression> conditions = na 
	EntryAction entry_action = na 
	ExitAction exit_action = na

	
type EntryLibraryOutput
	bool has_output = false 
	array<EntryRule> taken_actions = na
create_EntryLibraryOutput() =>
	EntryLibraryOutput output = EntryLibraryOutput.new() 
	output.taken_actions := array.new<EntryRule>()
	output
reset_EntryLibraryOutput(EntryLibraryOutput output) =>
	output.has_output := false 
	output.taken_actions.clear()

	
type EntryLibraryArgs
	ConditionDictionary condition_dict = na 
	array<EntryRule> entry_rules = na 
	array<BooleanExpression> compound_conditions = na 
	array<EntryAction> entry_actions = na 
	array<ExitAction> exit_actions = na
	EntryLibraryOutput output = na
	TradeLibraryArgs trade_library_args = na
	KeyLevelLibraryArgs key_level_library_args = na
	bool process_longs = true 
	bool process_shorts = true 
create_EntryLibraryArgs() => 
	EntryLibraryArgs args = EntryLibraryArgs.new() 
	args.condition_dict := create_ConditionDictionary()
	args.entry_rules := array.new<EntryRule>()
	args.compound_conditions := array.new<BooleanExpression>()
	args.entry_actions := array.new<EntryAction>()
	args.exit_actions := array.new<ExitAction>()
	args.output := create_EntryLibraryOutput()
	args.trade_library_args := create_TradeLibraryArgs()
	args.key_level_library_args := create_KeyLevelLibraryArgs()
	args


///////////////////////////////////
//////// FUNCTIONS FOR CONDITIONS 
//////////////////////////////////


get_condition_by_name(EntryLibraryArgs args, string name) => 
	bool found_condition = false 
	BooleanExpression condition = na 
	if args.compound_conditions.size() > 0
		for i = args.compound_conditions.size() - 1 to 0 
			BooleanExpression current_cond = args.compound_conditions.get(i)
			if current_cond.name == name 
				found_condition := true 
				condition := current_cond
	
	condition

create_and_add_compound_condition_helper(EntryLibraryArgs args, string name, bool is_simple_condition, string left_condition_name, string right_condition_name, BOOLEAN_OPERATOR op) => 
	BooleanExpression cond = na
	if is_simple_condition
		cond := create_BooleanExpression(name = name, is_base_level = is_simple_condition, base_level_val = false, left_val = na, right_val = na, operator = na)
	else
		BooleanExpression left_condition = get_condition_by_name(args, left_condition_name)
		BooleanExpression right_condition = get_condition_by_name(args, right_condition_name)
		cond := create_BooleanExpression(name = name, is_base_level = is_simple_condition, base_level_val = false, operator = op, left_val = left_condition, right_val = right_condition)
	args.compound_conditions.push(cond)
	cond //return the condition so we can use with var statement to call once per script 

create_and_add_compound_condition(EntryLibraryArgs args, string name, string left_condition_name, string right_condition_name, BOOLEAN_OPERATOR op) =>
	create_and_add_compound_condition_helper(args, name, false, left_condition_name, right_condition_name, op)

update_simple_condition(EntryLibraryArgs args, string condition_name, bool current_value) => 
	bool new_entry = ConditionDictionary_set_value(args.condition_dict, condition_name, current_value)
	if new_entry
		create_and_add_compound_condition_helper(args, condition_name, true, na, na, na) // adds simple condition

	//update the value of the compound condition
	BooleanExpression expr = get_condition_by_name(args, condition_name)
	expr.base_level_expression := current_value 


evaluate_conditions(EntryLibraryArgs args) =>
	array<BooleanExpression> conditions = args.compound_conditions
	if conditions.size() > 0
		for i = conditions.size() - 1 to 0 
			BooleanExpression current_condition = conditions.get(i)
			evaluate_BooleanExpression(current_condition)


stringify_conditions(EntryLibraryArgs args) => 
	string my_string = "Conditions:\n"
	array<BooleanExpression> conditions = args.compound_conditions
	if conditions.size() > 0
		for i = conditions.size() - 1 to 0 
			BooleanExpression current_condition = conditions.get(i)
			my_string += current_condition.name + " = " +str.tostring(current_condition.evaluated_value) + "\n"



	

///////////////////////////////////
//////// FUNCTIONS FOR ACTIONS
//////////////////////////////////

create_EntryAction(string name, ENTRY_ACTION_TYPE action_type, Direction trade_direction, OrderType order_type) => 
	EntryAction action = EntryAction.new(name, action_type, trade_direction, order_type)
	action 
// not to be used with the same action on every candle 
add_EntryAction(EntryLibraryArgs args, EntryAction action) =>
	args.entry_actions.push(action)
create_and_add_EntryAction(EntryLibraryArgs args, string name, ENTRY_ACTION_TYPE action_type, Direction trade_direction, OrderType order_type) =>
	EntryAction action = create_EntryAction(name, action_type, trade_direction, order_type)
	add_EntryAction(args, action)
	action // return action object so function can be used with var to be called once per script 

get_entry_action_by_name(EntryLibraryArgs args, string name) => 
	EntryAction Action = na 
	if args.entry_actions.size() > 0
		for i = args.entry_actions.size() - 1 to 0 
			EntryAction cur_entry = args.entry_actions.get(i)
			if cur_entry.name == name 
				Action := cur_entry
	Action


create_and_add_ExitAction(EntryLibraryArgs args, string name, EXIT_ACTION_TYPE action_type, float exit_value) =>
	ExitAction action = ExitAction.new(name, action_type, exit_value)
	action.trade_exit_info := TradeExitInfo.new()
	args.exit_actions.push(action)
	action

get_exit_action_by_name(EntryLibraryArgs args, string name) => 
	ExitAction Action = na 
	if args.exit_actions.size() > 0
		for i = args.exit_actions.size() - 1 to 0 
			ExitAction cur_exit = args.exit_actions.get(i)
			if cur_exit.name == name 
				Action := cur_exit
	Action

update_exit_action_value(EntryLibraryArgs args, string name, float value) =>
	int return_value = 0
	ExitAction exit_action = get_exit_action_by_name(args, name)
	if not na(exit_action)
		exit_action.rr_or_target_value := value 
	else
		return_value := -1 
	return_value

//returns 0 on success error code otherwise. Updates the exit action, which should apply to every rule with that action
EntryStrategyLibrary_updateExitActionBreakeven(EntryLibraryArgs args, string exit_action_name, bool will_break_even = true, int breakeven_on_n = 1)=>
	int return_value = 0
	ExitAction exit_action = get_exit_action_by_name(args, exit_action_name)
	if not na(exit_action)
		exit_action.trade_exit_info.will_break_even := will_break_even
		exit_action.trade_exit_info.breakeven_on_n := breakeven_on_n
	else
		return_value := -1 
	return_value	


// needs to be called on the same candle that the entry is for
create_trade_from_EntryAction_and_ExitAction(EntryLibraryArgs args, EntryAction entry_action, ExitAction exit_action, int candle_index) =>
	Entry entry = na 
	bool is_long = entry_action.trade_direction == Direction.Long 
	bool is_short = entry_action.trade_direction == Direction.Short
	float entry_price = 0
	float stop_loss_price = 0
	float target_price = 0
	//handle entry action 
	if entry_action.entry_type == ENTRY_ACTION_TYPE.EntryIsCandle
		if is_long 
			entry_price := high 
			stop_loss_price := low 
		else if is_short 
			entry_price := low 
			stop_loss_price := high 

	//process exit action 
	if exit_action.exit_type == EXIT_ACTION_TYPE.SetRiskRewardRatio
		float rr = exit_action.rr_or_target_value
		entry := create_Entry_with_target_RR(entry_action.trade_direction, entry_action.order_type, entry_price, stop_loss_price, rr, candle_index)
	else if exit_action.exit_type == EXIT_ACTION_TYPE.SetTargetPrice
		float target = exit_action.rr_or_target_value
		entry := create_Entry_with_target_price(entry_action.trade_direction, entry_action.order_type, entry_price, stop_loss_price, target, candle_index)

	if exit_action.trade_exit_info.will_break_even
		TradeManagerLibrary_setEntryBreakeven(args.trade_library_args, entry,exit_action.trade_exit_info.breakeven_on_n)
	entry

take_active_trades(EntryLibraryArgs args) =>
	array<EntryRule> active_actions = args.output.taken_actions
	if active_actions.size() > 0 
		for i = active_actions.size() - 1 to 0 
			EntryAction current_entry_action = active_actions.get(i).entry_action
			ExitAction current_exit_action = active_actions.get(i).exit_action
			Entry entry = create_trade_from_EntryAction_and_ExitAction(args, current_entry_action, current_exit_action, bar_index)
			place_trade(args.trade_library_args, entry)


	
///////////////////////////////////
//////// FUNCTIONS FOR RULES
//////////////////////////////////

create_and_add_EntryRule(EntryLibraryArgs args, string name, string condition_name, string entry_action_name, string exit_action_name) => 
	//look for the condition by its name 
	BooleanExpression cond = get_condition_by_name(args, condition_name)
	EntryAction entry_action = get_entry_action_by_name(args, entry_action_name)
	ExitAction exit_action = get_exit_action_by_name(args, exit_action_name)
	array<BooleanExpression> conditions = array.new<BooleanExpression>()
	conditions.push(cond)
	EntryRule rule = EntryRule.new(name, conditions, entry_action, exit_action)
	args.entry_rules.push(rule)
	rule 
	 

get_rule_by_name(EntryLibraryArgs args, string name) =>  
	EntryRule rule = na 
	array<EntryRule> entry_rules = args.entry_rules
	if entry_rules.size() > 0 
		for i = entry_rules.size() - 1 to 0 
			EntryRule current_rule = entry_rules.get(i)
			if current_rule.rule_name == name 
				rule := current_rule 
	rule
	

add_condition_to_EntryRule(EntryLibraryArgs args, string rule_name, string condition_name) => 
	EntryRule rule = get_rule_by_name(args, rule_name)
	BooleanExpression cond = get_condition_by_name(args, condition_name)

	//add condition if it does not already exist
	bool already_exists = false 
	if rule.conditions.size() > 0 
		for i = rule.conditions.size() - 1 to 0
			if rule.conditions.get(i).name == condition_name 
				already_exists := true 
	
	if not already_exists
		rule.conditions.push(cond)



process_EntryRules(EntryLibraryArgs args) => 
	array<EntryRule> entry_rules = args.entry_rules 
	if entry_rules.size() > 0
		for i = entry_rules.size() - 1 to 0 
			EntryRule current_rule = entry_rules.get(i)
			//make sure all conditions are valid 
			bool all_conditions_met = true
			for j = current_rule.conditions.size() - 1 to 0
				if current_rule.conditions.get(j).evaluated_value != true 
					all_conditions_met := false 
			
			if all_conditions_met
				//process if we are allowed to take longs and/or shorts 
				bool is_long = current_rule.entry_action.trade_direction == Direction.Long
				bool is_short = current_rule.entry_action.trade_direction == Direction.Short
				if (is_long and args.process_longs) or (is_short and args.process_shorts)
					args.output.taken_actions.push(current_rule)
					args.output.has_output := true
				
				
has_output(EntryLibraryArgs args) =>
	args.output.has_output
get_output(EntryLibraryArgs args) =>
	args.output.taken_actions

EntryStrategyLibrary_process_candle(EntryLibraryArgs args) => 
	// clear the output 
	reset_EntryLibraryOutput(args.output)
	//first evaluate / update conditions
	evaluate_conditions(args)
	// then check rules for conditions that have been met 
	process_EntryRules(args)
	//then take each active trade action and create a trade from it 
	take_active_trades(args)
	//process the trades with the trade library 
	TradeManagerLibrary_process_candle(args.trade_library_args)
	



// === Strategies/FinalStrategy.pine ===
//@version=6
strategy("FinalStrat")
//place a trade based on an entry 
FinalStrategy_process_entry(Entry entry) =>
    bool should_place_trade = (entry.state == EntryState.Placed) and (entry.index == bar_index)
    if should_place_trade
        string trade_id = str.tostring(entry.index)
        entry.additional_data.trade_id := trade_id
        bool is_long = entry.dir == Direction.Long
        bool is_short = entry.dir == Direction.Short
        bool is_entry_limit = entry.orderType == OrderType.Limit
        bool is_entry_stop = entry.orderType == OrderType.Stop
        if is_entry_limit
            strategy.entry(id = trade_id, direction = is_long ? strategy.long : strategy.short, limit = entry.entryPrice, qty = entry.num_shares)
        if is_entry_stop
            strategy.entry(id = trade_id, direction = is_long ? strategy.long : strategy.short, stop = entry.entryPrice, qty = entry.num_shares)
        string exit_id = "exit_" + trade_id
        strategy.exit(id = exit_id, from_entry = trade_id, stop = entry.stopLossPrice, limit = entry.targetPrice)

    bool should_cancel_trade = (entry.state == EntryState.Invalidated)
    if should_cancel_trade
        strategy.cancel(id = entry.additional_data.trade_id)


//////////////////////////////////////// TESTING ///////////////////////////////////////////

var EntryLibraryArgs args = create_EntryLibraryArgs()
args.trade_library_args.debugger.print_active_trades_when_something_changes := false 
// want to code in Longs for Green Down Candles, and Shorts for Red Up Candles 

// simple conditions,  red up candle and green down candle 
var string red_candle_condition_name = "is_red_candle"
var string green_candle_condition_name = "is_green_candle"
var string up_candle_condition_name = "is_up_candle"
var string down_candle_condition_name = "is_down_candle"
is_current_candle_red() =>
	close < open
is_current_candle_green() => 
	close > open 
is_candle_up() => 
	(high > high[1]) and (low > low[1])
is_candle_down() => 
	(high < high[1]) and (low < low[1])
update_simple_condition(args,red_candle_condition_name,is_current_candle_red())
update_simple_condition(args,green_candle_condition_name, is_current_candle_green())
update_simple_condition(args, up_candle_condition_name, is_candle_up())
update_simple_condition(args, down_candle_condition_name, is_candle_down())

var string past_start_time_condition_name = "is_past_start_time"
is_after_datetime(int year_in, int month_in, int day_in, int hour_in, int minute_in) =>
    int target_timestamp = timestamp("UTC", year_in, month_in, day_in, hour_in, minute_in)
    bool is_past = time >= target_timestamp
    is_past
update_simple_condition(args,past_start_time_condition_name, is_after_datetime(2025,6,4,0,0))

// compound conditions 
var string red_up_candle_condition_name = "is_red_up_candle"
var string green_down_candle_condition_name = "is_green_down_candle"
var red_up_condition = create_and_add_compound_condition(args, red_up_candle_condition_name, red_candle_condition_name, up_candle_condition_name, BOOLEAN_OPERATOR.AND)
var green_down_condition = create_and_add_compound_condition(args, green_down_candle_condition_name, green_candle_condition_name, down_candle_condition_name, BOOLEAN_OPERATOR.AND)


// entry actions 
var entry_action_long_stop_name = "Place Long Stop On Current Candle"
var entry_action_short_stop_name = "Place Short Stop On Current Candle"
var EntryAction entry_action_long_stop = create_and_add_EntryAction(args, entry_action_long_stop_name, ENTRY_ACTION_TYPE.EntryIsCandle,Direction.Long, OrderType.Stop)
var EntryAction entry_action_short_stop = create_and_add_EntryAction(args, entry_action_short_stop_name, ENTRY_ACTION_TYPE.EntryIsCandle,Direction.Short, OrderType.Stop)

//key levels 
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma20", ta.sma(close, 20))
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma50", ta.sma(close, 50))
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma100", ta.sma(close, 100))
KeyLevelLibrary_updateKeyLevel(args.key_level_library_args, "sma200", ta.sma(close, 200))

var string touching_sma_condition_name = "TouchingSMA_20_50_100_200"
update_simple_condition(args,touching_sma_condition_name, KeyLevelLibrary_isPriceTouchingAnyKeyLevel(args.key_level_library_args))



// Rules Taking Entries touching Key Levels For 1R
var exit_action_1R_name = "Exit at 1R"
var ExitAction exit_action_1R = create_and_add_ExitAction(args, exit_action_1R_name, EXIT_ACTION_TYPE.SetRiskRewardRatio, 1)
var rc = EntryStrategyLibrary_updateExitActionBreakeven(args, exit_action_1R_name, will_break_even = true, breakeven_on_n = 1)

var string red_up_1r_rule_name = "Red_Up_Candle_Touching_Key_Level_1R_Rule"
var string green_down_1r_rule_name = "Green_Down_Candle_Touching_Key_Level_1R_Rule"
var EntryRule red_up_1r_rule = create_and_add_EntryRule(args, red_up_1r_rule_name, red_up_candle_condition_name, entry_action_short_stop_name, exit_action_1R_name)
var EntryRule green_down_1r_rule = create_and_add_EntryRule(args, green_down_1r_rule_name, green_down_candle_condition_name, entry_action_long_stop_name, exit_action_1R_name)

add_condition_to_EntryRule(args, red_up_1r_rule_name, past_start_time_condition_name)
add_condition_to_EntryRule(args, green_down_1r_rule_name, past_start_time_condition_name)
//add_condition_to_EntryRule(args, red_up_1r_rule_name, touching_sma_condition_name)
//add_condition_to_EntryRule(args, green_down_1r_rule_name, touching_sma_condition_name)


// Rules Taking Entries making 1R or less touching nearest key level 
// var exit_action_nearest_key_level_long_name = "Exit at nearest key level LONG"
// var ExitAction exit_action_nearest_key_level_long = create_and_add_ExitAction(args, exit_action_nearest_key_level_long_name, EXIT_ACTION_TYPE.SetTargetPrice, 0) //need to update this every bar
// var exit_action_nearest_key_level_short_name = "Exit at nearest key level SHORT"
// var ExitAction exit_action_nearest_key_level_short = create_and_add_ExitAction(args, exit_action_nearest_key_level_short_name, EXIT_ACTION_TYPE.SetTargetPrice, 0) //need to update this every bar

// var string red_up_nearest_level_rule_name = "Red_Up_Candle_Near_Key_Level_Rule"
// var string green_down_nearest_level_rule_name = "Green_Down_Candle_Near_Key_Level_Rule"
// var EntryRule red_up_nearest_level_rule = create_and_add_EntryRule(args, red_up_nearest_level_rule_name, red_up_candle_condition_name, entry_action_short_stop_name, exit_action_nearest_key_level_short_name)
// var EntryRule green_down_nearest_level_rule = create_and_add_EntryRule(args, green_down_nearest_level_rule_name, green_down_candle_condition_name, entry_action_long_stop_name, exit_action_nearest_key_level_long_name)


// var string near_sma_condition_long_name = "NearSMA_20_50_100_200 LONG"
// KeyLevel nearest_key_level_long = KeyLevelLibrary_getNearestKeyLevelLong(args.key_level_library_args, true)
// bool is_near_sma_long_helper = false 
// if not na(nearest_key_level_long)
//     is_near_sma_long_helper := MiscLibrary_isMakingAtMost_R_toPrice(high, low, nearest_key_level_long.current_value, 1)
//     update_exit_action_value(args, exit_action_nearest_key_level_long_name, nearest_key_level_long.current_value)
// update_simple_condition(args, near_sma_condition_long_name, is_near_sma_long_helper)


// var string near_sma_condition_short_name = "NearSMA_20_50_100_200 SHORT"
// KeyLevel nearest_key_level_short = KeyLevelLibrary_getNearestKeyLevelShort(args.key_level_library_args, true)
// bool is_near_sma_short_helper = false 
// if not na(nearest_key_level_short)
//     is_near_sma_short_helper := MiscLibrary_isMakingAtMost_R_toPrice(low, high, nearest_key_level_short.current_value, 1)
//     update_exit_action_value(args, exit_action_nearest_key_level_short_name, nearest_key_level_short.current_value)
// update_simple_condition(args, near_sma_condition_short_name, is_near_sma_long_helper)


// add_condition_to_EntryRule(args, red_up_nearest_level_rule_name, past_start_time_condition_name)
// add_condition_to_EntryRule(args, green_down_nearest_level_rule_name, past_start_time_condition_name)
// add_condition_to_EntryRule(args, red_up_nearest_level_rule_name, near_sma_condition_short_name)
// add_condition_to_EntryRule(args, green_down_nearest_level_rule_name, near_sma_condition_long_name)



args.process_longs := true 
args.process_shorts := false 
args.trade_library_args.parameters.pyramiding_allowed := true
EntryStrategyLibrary_process_candle(args)

array<Entry> entries = args.trade_library_args.entry_array
if entries.size() > 0 
    for i = entries.size() - 1 to 0 
        FinalStrategy_process_entry(entries.get(i))







